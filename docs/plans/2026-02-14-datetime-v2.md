# @f-o-t/datetime v2.0.0 — Functional Refactor + BigInt Precision

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Refactor @f-o-t/datetime from class-based (v0.1.5) to functional API with bigint-backed high-precision timestamps, then migrate 10 FOT libraries to use it.

**Architecture:** DateTime becomes a plain `{ timestamp: bigint, scale: DateTimeScale }` object. All operations are pure functions. Uses `@f-o-t/bigint` for precision arithmetic. Plugins are collections of pure functions (not class extensions).

**Tech Stack:** TypeScript, Bun, Zod ^4.3.6, @f-o-t/bigint ^1.0.4, @f-o-t/cli, @f-o-t/config

---

## Context

**Current state:** `libraries/datetime/` exists at v0.1.5 with a 694-line `DateTime` class, 4 plugins (timezone, business-days, format, relative-time) using `declare module` to extend the class. Tests use Bun's native `bun:test`.

**Problem:** Violates FOT functional principle (classes only for errors). Limited to millisecond precision. Can't represent PostgreSQL microseconds or Oracle nanoseconds without precision loss.

**Reference:** Follow `@f-o-t/bigint` patterns — pure functions, object parameters, Zod schemas, `__tests__/` directory.

**Key design decisions:**
- `DateTimeScale`: `0` = seconds, `3` = ms, `6` = microseconds (default), `9` = nanoseconds
- Default scale is `6` (microseconds) for database compatibility
- Plugins are subpath exports (`@f-o-t/datetime/plugins/timezone`) not class extensions
- No `declare module` — plugins export standalone functions

---

## Task 1: Setup — Types, Schemas, Errors

**Files:**
- Create: `libraries/datetime/src/types.ts`
- Create: `libraries/datetime/src/schemas.ts`
- Create: `libraries/datetime/src/errors.ts`
- Test: `libraries/datetime/__tests__/schemas.test.ts`

**Step 1: Write the types file**

```typescript
// libraries/datetime/src/types.ts

export type DateTimeScale = 0 | 3 | 6 | 9;

export const DateTimeScales = {
  SECONDS: 0,
  MILLISECONDS: 3,
  MICROSECONDS: 6,
  NANOSECONDS: 9,
} as const satisfies Record<string, DateTimeScale>;

export type DateTime = {
  readonly timestamp: bigint;
  readonly scale: DateTimeScale;
};

export type TimeUnit =
  | "nanosecond"
  | "microsecond"
  | "millisecond"
  | "second"
  | "minute"
  | "hour"
  | "day"
  | "week"
  | "month"
  | "year";

export type DateInput = Date | string | number | bigint | DateTime | undefined;

export type DateTimeOptions = {
  scale?: DateTimeScale;
};
```

**Step 2: Write the schemas file**

```typescript
// libraries/datetime/src/schemas.ts
import { z } from "zod";

export const DateTimeScaleSchema = z.union([
  z.literal(0),
  z.literal(3),
  z.literal(6),
  z.literal(9),
]);

export const DateTimeSchema = z.object({
  timestamp: z.bigint(),
  scale: DateTimeScaleSchema,
});

export const TimeUnitSchema = z.enum([
  "nanosecond", "microsecond", "millisecond", "second",
  "minute", "hour", "day", "week", "month", "year",
]);

export const DateInputSchema = z.union([
  z.date(),
  z.string(),
  z.number(),
  z.bigint(),
  DateTimeSchema,
  z.undefined(),
]);

export const DateTimeOptionsSchema = z.object({
  scale: DateTimeScaleSchema.optional(),
}).optional();
```

**Step 3: Write the errors file**

```typescript
// libraries/datetime/src/errors.ts
export class InvalidDateError extends Error {
  constructor(input: unknown) {
    super(`Invalid date input: ${String(input)}`);
    this.name = "InvalidDateError";
  }
}
```

**Step 4: Write schema tests**

```typescript
// libraries/datetime/__tests__/schemas.test.ts
import { describe, expect, test } from "bun:test";
import { DateTimeSchema, DateTimeScaleSchema, DateInputSchema } from "../src/schemas";

describe("DateTimeScaleSchema", () => {
  test("accepts valid scales", () => {
    expect(DateTimeScaleSchema.parse(0)).toBe(0);
    expect(DateTimeScaleSchema.parse(3)).toBe(3);
    expect(DateTimeScaleSchema.parse(6)).toBe(6);
    expect(DateTimeScaleSchema.parse(9)).toBe(9);
  });

  test("rejects invalid scales", () => {
    expect(() => DateTimeScaleSchema.parse(1)).toThrow();
    expect(() => DateTimeScaleSchema.parse(5)).toThrow();
  });
});

describe("DateTimeSchema", () => {
  test("accepts valid DateTime", () => {
    const result = DateTimeSchema.parse({ timestamp: 1000000n, scale: 6 });
    expect(result.timestamp).toBe(1000000n);
    expect(result.scale).toBe(6);
  });

  test("rejects non-bigint timestamp", () => {
    expect(() => DateTimeSchema.parse({ timestamp: 1000, scale: 6 })).toThrow();
  });
});
```

**Step 5: Run tests to verify they pass**

Run: `cd libraries/datetime && bun test __tests__/schemas.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add libraries/datetime/src/types.ts libraries/datetime/src/schemas.ts libraries/datetime/src/errors.ts libraries/datetime/__tests__/schemas.test.ts
git commit -m "feat(datetime): add v2 types, schemas, and errors"
```

---

## Task 2: Core — Factory Functions

**Files:**
- Create: `libraries/datetime/src/core/factory.ts`
- Create: `libraries/datetime/src/utils/scale.ts`
- Create: `libraries/datetime/src/utils/constants.ts`
- Test: `libraries/datetime/__tests__/core/factory.test.ts`

**Step 1: Write scale utilities**

```typescript
// libraries/datetime/src/utils/constants.ts
export const SCALE_FACTORS: Record<number, bigint> = {
  0: 1n,
  3: 1000n,
  6: 1000000n,
  9: 1000000000n,
};
```

```typescript
// libraries/datetime/src/utils/scale.ts
import type { DateTimeScale, DateTime } from "../types";
import { SCALE_FACTORS } from "./constants";

export function convertTimestamp(
  timestamp: bigint,
  fromScale: DateTimeScale,
  toScale: DateTimeScale,
): bigint {
  if (fromScale === toScale) return timestamp;
  const fromFactor = SCALE_FACTORS[fromScale]!;
  const toFactor = SCALE_FACTORS[toScale]!;
  if (toScale > fromScale) {
    return timestamp * (toFactor / fromFactor);
  }
  return timestamp / (fromFactor / toFactor);
}

export function alignScales(a: DateTime, b: DateTime): [bigint, bigint, DateTimeScale] {
  const targetScale = Math.max(a.scale, b.scale) as DateTimeScale;
  return [
    convertTimestamp(a.timestamp, a.scale, targetScale),
    convertTimestamp(b.timestamp, b.scale, targetScale),
    targetScale,
  ];
}
```

**Step 2: Write factory functions**

```typescript
// libraries/datetime/src/core/factory.ts
import type { DateInput, DateTime, DateTimeOptions, DateTimeScale } from "../types";
import { InvalidDateError } from "../errors";
import { SCALE_FACTORS } from "../utils/constants";
import { convertTimestamp } from "../utils/scale";

const DEFAULT_SCALE: DateTimeScale = 6; // microseconds

export function datetime(
  input?: DateInput,
  options?: DateTimeOptions,
): DateTime {
  const scale = options?.scale ?? DEFAULT_SCALE;

  if (input === undefined || input === null) {
    return now(scale);
  }

  if (typeof input === "object" && "timestamp" in input && "scale" in input) {
    // Already a DateTime — convert scale if needed
    return {
      timestamp: convertTimestamp(input.timestamp, input.scale, scale),
      scale,
    };
  }

  if (input instanceof Date) {
    return fromDate(input, scale);
  }

  if (typeof input === "string") {
    return fromISO(input, scale);
  }

  if (typeof input === "number") {
    // Treat as milliseconds (JS convention)
    const ms = BigInt(Math.trunc(input));
    return {
      timestamp: convertTimestamp(ms, 3, scale),
      scale,
    };
  }

  if (typeof input === "bigint") {
    // Treat as microseconds by default
    return { timestamp: convertTimestamp(input, 6, scale), scale };
  }

  throw new InvalidDateError(input);
}

export function now(scale?: DateTimeScale): DateTime {
  const s = scale ?? DEFAULT_SCALE;
  const ms = BigInt(Date.now());
  return {
    timestamp: convertTimestamp(ms, 3, s),
    scale: s,
  };
}

export function fromDate(date: Date, scale?: DateTimeScale): DateTime {
  const s = scale ?? DEFAULT_SCALE;
  const ms = date.getTime();
  if (Number.isNaN(ms)) throw new InvalidDateError(date);
  return {
    timestamp: convertTimestamp(BigInt(ms), 3, s),
    scale: s,
  };
}

export function fromISO(iso: string, scale?: DateTimeScale): DateTime {
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) throw new InvalidDateError(iso);
  return fromDate(date, scale);
}

export function fromUnix(timestamp: number | bigint, scale?: DateTimeScale): DateTime {
  const s = scale ?? DEFAULT_SCALE;
  const ts = typeof timestamp === "bigint" ? timestamp : BigInt(Math.trunc(timestamp));
  // Unix timestamps are in seconds
  return {
    timestamp: convertTimestamp(ts, 0, s),
    scale: s,
  };
}

export function fromDatabase(
  value: string | bigint,
  dbType: "postgres" | "mysql" | "oracle" = "postgres",
): DateTime {
  if (typeof value === "bigint") {
    const dbScale: DateTimeScale = dbType === "oracle" ? 9 : 6;
    return { timestamp: value, scale: dbScale };
  }
  // String timestamp from database
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) throw new InvalidDateError(value);
  const dbScale: DateTimeScale = dbType === "oracle" ? 9 : 6;
  return fromDate(date, dbScale);
}
```

**Step 3: Write factory tests**

```typescript
// libraries/datetime/__tests__/core/factory.test.ts
import { describe, expect, test } from "bun:test";
import { datetime, now, fromDate, fromISO, fromUnix, fromDatabase } from "../../src/core/factory";
import { InvalidDateError } from "../../src/errors";

describe("datetime()", () => {
  test("creates DateTime from no input (now)", () => {
    const dt = datetime();
    expect(dt.scale).toBe(6);
    expect(typeof dt.timestamp).toBe("bigint");
    expect(dt.timestamp > 0n).toBe(true);
  });

  test("creates DateTime from Date", () => {
    const date = new Date("2024-01-15T12:00:00.000Z");
    const dt = datetime(date);
    expect(dt.scale).toBe(6);
    // 1705320000000 ms → microseconds
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("creates DateTime from ISO string", () => {
    const dt = datetime("2024-01-15T12:00:00.000Z");
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("creates DateTime from number (milliseconds)", () => {
    const dt = datetime(1705320000000);
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("creates DateTime from bigint (microseconds)", () => {
    const dt = datetime(1705320000000000n);
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("creates DateTime from another DateTime", () => {
    const dt1 = datetime("2024-01-15T12:00:00.000Z");
    const dt2 = datetime(dt1);
    expect(dt2.timestamp).toBe(dt1.timestamp);
  });

  test("respects scale option", () => {
    const dt = datetime("2024-01-15T12:00:00.000Z", { scale: 3 });
    expect(dt.scale).toBe(3);
    expect(dt.timestamp).toBe(1705320000000n);
  });

  test("throws InvalidDateError for invalid string", () => {
    expect(() => datetime("not-a-date")).toThrow(InvalidDateError);
  });

  test("throws InvalidDateError for invalid Date", () => {
    expect(() => datetime(new Date("invalid"))).toThrow(InvalidDateError);
  });
});

describe("now()", () => {
  test("returns current time with default microsecond scale", () => {
    const dt = now();
    expect(dt.scale).toBe(6);
    expect(dt.timestamp > 0n).toBe(true);
  });

  test("returns current time with custom scale", () => {
    const dt = now(3);
    expect(dt.scale).toBe(3);
  });
});

describe("fromUnix()", () => {
  test("converts unix seconds to DateTime", () => {
    const dt = fromUnix(1705320000);
    expect(dt.scale).toBe(6);
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("converts unix bigint to DateTime", () => {
    const dt = fromUnix(1705320000n);
    expect(dt.timestamp).toBe(1705320000000000n);
  });
});

describe("fromDatabase()", () => {
  test("parses postgres timestamp string", () => {
    const dt = fromDatabase("2024-01-15T12:00:00.000Z", "postgres");
    expect(dt.scale).toBe(6);
  });

  test("parses bigint as postgres microseconds", () => {
    const dt = fromDatabase(1705320000000000n, "postgres");
    expect(dt.scale).toBe(6);
    expect(dt.timestamp).toBe(1705320000000000n);
  });

  test("parses bigint as oracle nanoseconds", () => {
    const dt = fromDatabase(1705320000000000000n, "oracle");
    expect(dt.scale).toBe(9);
  });
});
```

**Step 4: Run tests**

Run: `cd libraries/datetime && bun test __tests__/core/factory.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add libraries/datetime/src/core/factory.ts libraries/datetime/src/utils/ libraries/datetime/__tests__/core/factory.test.ts
git commit -m "feat(datetime): add factory functions (datetime, now, fromUnix, fromISO, fromDatabase)"
```

---

## Task 3: Core — Getters

**Files:**
- Create: `libraries/datetime/src/core/getters.ts`
- Test: `libraries/datetime/__tests__/core/getters.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/core/getters.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import {
  year, month, day, hour, minute, second, millisecond,
  microsecond, nanosecond, dayOfWeek, dayOfYear, daysInMonth,
  daysInYear, isLeapYear,
} from "../../src/core/getters";

// 2024-01-15T14:30:45.123Z (Monday)
const dt = datetime("2024-01-15T14:30:45.123Z");

describe("getters", () => {
  test("year()", () => expect(year(dt)).toBe(2024));
  test("month() is 1-indexed", () => expect(month(dt)).toBe(1));
  test("day()", () => expect(day(dt)).toBe(15));
  test("hour()", () => expect(hour(dt)).toBe(14));
  test("minute()", () => expect(minute(dt)).toBe(30));
  test("second()", () => expect(second(dt)).toBe(45));
  test("millisecond()", () => expect(millisecond(dt)).toBe(123));
  test("microsecond()", () => expect(microsecond(dt)).toBe(0));
  test("nanosecond()", () => expect(nanosecond(dt)).toBe(0));
  test("dayOfWeek() Monday=1", () => expect(dayOfWeek(dt)).toBe(1));
  test("dayOfYear()", () => expect(dayOfYear(dt)).toBe(15));
  test("daysInMonth() January", () => expect(daysInMonth(dt)).toBe(31));
  test("daysInYear() 2024 is leap", () => expect(daysInYear(dt)).toBe(366));
  test("isLeapYear() 2024", () => expect(isLeapYear(dt)).toBe(true));
});

describe("leap year edge cases", () => {
  test("2023 is not leap", () => {
    expect(isLeapYear(datetime("2023-06-15T00:00:00Z"))).toBe(false);
  });
  test("2000 is leap (divisible by 400)", () => {
    expect(isLeapYear(datetime("2000-06-15T00:00:00Z"))).toBe(true);
  });
  test("1900 is not leap (divisible by 100 not 400)", () => {
    expect(isLeapYear(datetime("1900-06-15T00:00:00Z"))).toBe(false);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd libraries/datetime && bun test __tests__/core/getters.test.ts`
Expected: FAIL — module not found

**Step 3: Implement getters**

```typescript
// libraries/datetime/src/core/getters.ts
import type { DateTime } from "../types";
import { convertTimestamp } from "../utils/scale";

function toJSDate(dt: DateTime): Date {
  const ms = convertTimestamp(dt.timestamp, dt.scale, 3);
  return new Date(Number(ms));
}

export function year(dt: DateTime): number {
  return toJSDate(dt).getUTCFullYear();
}

export function month(dt: DateTime): number {
  return toJSDate(dt).getUTCMonth() + 1; // 1-indexed
}

export function day(dt: DateTime): number {
  return toJSDate(dt).getUTCDate();
}

export function hour(dt: DateTime): number {
  return toJSDate(dt).getUTCHours();
}

export function minute(dt: DateTime): number {
  return toJSDate(dt).getUTCMinutes();
}

export function second(dt: DateTime): number {
  return toJSDate(dt).getUTCSeconds();
}

export function millisecond(dt: DateTime): number {
  return toJSDate(dt).getUTCMilliseconds();
}

export function microsecond(dt: DateTime): number {
  if (dt.scale < 6) return 0;
  const us = convertTimestamp(dt.timestamp, dt.scale, 6);
  return Number(us % 1000000n % 1000n);
}

export function nanosecond(dt: DateTime): number {
  if (dt.scale < 9) return 0;
  const ns = convertTimestamp(dt.timestamp, dt.scale, 9);
  return Number(ns % 1000000000n % 1000n);
}

export function dayOfWeek(dt: DateTime): number {
  // 0=Sunday in JS, we keep 0=Sunday
  return toJSDate(dt).getUTCDay();
}

export function dayOfYear(dt: DateTime): number {
  const d = toJSDate(dt);
  const start = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const diff = d.getTime() - start.getTime();
  return Math.floor(diff / 86400000) + 1;
}

export function daysInMonth(dt: DateTime): number {
  const d = toJSDate(dt);
  // Day 0 of next month = last day of current month
  return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + 1, 0)).getUTCDate();
}

export function daysInYear(dt: DateTime): number {
  return isLeapYear(dt) ? 366 : 365;
}

export function isLeapYear(dt: DateTime): boolean {
  const y = year(dt);
  return (y % 4 === 0 && y % 100 !== 0) || y % 400 === 0;
}

export function isValid(dt: DateTime): boolean {
  const d = toJSDate(dt);
  return !Number.isNaN(d.getTime());
}

export function weekOfYear(dt: DateTime): number {
  const d = toJSDate(dt);
  const startOfYear = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const pastDays = (d.getTime() - startOfYear.getTime()) / 86400000;
  return Math.ceil((pastDays + startOfYear.getUTCDay() + 1) / 7);
}
```

**Step 4: Run tests to verify they pass**

Run: `cd libraries/datetime && bun test __tests__/core/getters.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add libraries/datetime/src/core/getters.ts libraries/datetime/__tests__/core/getters.test.ts
git commit -m "feat(datetime): add getter functions (year, month, day, dayOfWeek, etc.)"
```

---

## Task 4: Core — Arithmetic (add, subtract, startOf, endOf)

**Files:**
- Create: `libraries/datetime/src/core/arithmetic.ts`
- Test: `libraries/datetime/__tests__/core/arithmetic.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/core/arithmetic.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import {
  add, subtract, addDays, addHours, addMonths, addYears,
  subtractDays, startOfDay, endOfDay, startOfMonth, endOfMonth,
  startOfYear, endOfYear,
} from "../../src/core/arithmetic";
import { year, month, day, hour, minute, second } from "../../src/core/getters";

const dt = datetime("2024-01-15T14:30:45.123Z");

describe("add()", () => {
  test("adds days", () => {
    const result = add(dt, 5, "day");
    expect(day(result)).toBe(20);
  });

  test("adds hours", () => {
    const result = add(dt, 3, "hour");
    expect(hour(result)).toBe(17);
  });

  test("adds months with overflow", () => {
    const jan31 = datetime("2024-01-31T12:00:00Z");
    const result = add(jan31, 1, "month");
    // Feb doesn't have 31 days, should clamp to 29 (2024 is leap)
    expect(month(result)).toBe(2);
    expect(day(result)).toBe(29);
  });

  test("adds years across leap year boundary", () => {
    const feb29 = datetime("2024-02-29T12:00:00Z");
    const result = add(feb29, 1, "year");
    expect(year(result)).toBe(2025);
    expect(month(result)).toBe(2);
    expect(day(result)).toBe(28);
  });
});

describe("subtract()", () => {
  test("subtracts days", () => {
    const result = subtract(dt, 10, "day");
    expect(day(result)).toBe(5);
  });
});

describe("convenience functions", () => {
  test("addDays()", () => expect(day(addDays(dt, 1))).toBe(16));
  test("addHours()", () => expect(hour(addHours(dt, 2))).toBe(16));
  test("addMonths()", () => expect(month(addMonths(dt, 2))).toBe(3));
  test("addYears()", () => expect(year(addYears(dt, 1))).toBe(2025));
  test("subtractDays()", () => expect(day(subtractDays(dt, 5))).toBe(10));
});

describe("startOf / endOf", () => {
  test("startOfDay()", () => {
    const result = startOfDay(dt);
    expect(hour(result)).toBe(0);
    expect(minute(result)).toBe(0);
    expect(second(result)).toBe(0);
    expect(day(result)).toBe(15);
  });

  test("endOfDay()", () => {
    const result = endOfDay(dt);
    expect(hour(result)).toBe(23);
    expect(minute(result)).toBe(59);
    expect(second(result)).toBe(59);
  });

  test("startOfMonth()", () => {
    const result = startOfMonth(dt);
    expect(day(result)).toBe(1);
    expect(hour(result)).toBe(0);
  });

  test("endOfMonth() January", () => {
    const result = endOfMonth(dt);
    expect(day(result)).toBe(31);
    expect(hour(result)).toBe(23);
  });

  test("startOfYear()", () => {
    const result = startOfYear(dt);
    expect(month(result)).toBe(1);
    expect(day(result)).toBe(1);
  });

  test("endOfYear()", () => {
    const result = endOfYear(dt);
    expect(month(result)).toBe(12);
    expect(day(result)).toBe(31);
  });
});

describe("immutability", () => {
  test("add does not mutate original", () => {
    const original = datetime("2024-01-15T12:00:00Z");
    const originalTs = original.timestamp;
    add(original, 5, "day");
    expect(original.timestamp).toBe(originalTs);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd libraries/datetime && bun test __tests__/core/arithmetic.test.ts`
Expected: FAIL

**Step 3: Implement arithmetic**

```typescript
// libraries/datetime/src/core/arithmetic.ts
import type { DateTime, DateTimeScale, TimeUnit } from "../types";
import { SCALE_FACTORS } from "../utils/constants";
import { convertTimestamp } from "../utils/scale";

function toJSDate(dt: DateTime): Date {
  const ms = convertTimestamp(dt.timestamp, dt.scale, 3);
  return new Date(Number(ms));
}

function fromJSDate(date: Date, scale: DateTimeScale): DateTime {
  return {
    timestamp: convertTimestamp(BigInt(date.getTime()), 3, scale),
    scale,
  };
}

const UNIT_MICROSECONDS: Record<string, bigint> = {
  nanosecond: 0n, // handled separately
  microsecond: 1n,
  millisecond: 1000n,
  second: 1000000n,
  minute: 60000000n,
  hour: 3600000000n,
  day: 86400000000n,
  week: 604800000000n,
};

export function add(dt: DateTime, amount: number, unit: TimeUnit): DateTime {
  // Calendar units need special handling
  if (unit === "month" || unit === "year") {
    const d = toJSDate(dt);
    if (unit === "month") {
      const targetMonth = d.getUTCMonth() + amount;
      d.setUTCMonth(targetMonth);
      // Clamp day if month overflowed (e.g., Jan 31 + 1 month)
      const expectedMonth = ((d.getUTCMonth() % 12) + 12) % 12;
      const actualTargetMonth = ((targetMonth % 12) + 12) % 12;
      if (expectedMonth !== actualTargetMonth) {
        d.setUTCDate(0); // Last day of previous month
      }
    } else {
      const targetYear = d.getUTCFullYear() + amount;
      d.setUTCFullYear(targetYear);
      // Handle Feb 29 → Feb 28 for non-leap years
      if (d.getUTCMonth() !== toJSDate(dt).getUTCMonth()) {
        d.setUTCDate(0);
      }
    }
    return fromJSDate(d, dt.scale);
  }

  // Fixed-duration units: use bigint arithmetic
  const usPerUnit = UNIT_MICROSECONDS[unit];
  if (usPerUnit === undefined) throw new Error(`Unknown unit: ${unit}`);

  if (unit === "nanosecond") {
    const nsAmount = BigInt(amount);
    const tsInNs = convertTimestamp(dt.timestamp, dt.scale, 9);
    return {
      timestamp: convertTimestamp(tsInNs + nsAmount, 9, dt.scale),
      scale: dt.scale,
    };
  }

  const usAmount = usPerUnit * BigInt(amount);
  const tsInUs = convertTimestamp(dt.timestamp, dt.scale, 6);
  return {
    timestamp: convertTimestamp(tsInUs + usAmount, 6, dt.scale),
    scale: dt.scale,
  };
}

export function subtract(dt: DateTime, amount: number, unit: TimeUnit): DateTime {
  return add(dt, -amount, unit);
}

// Convenience functions
export function addYears(dt: DateTime, n: number): DateTime { return add(dt, n, "year"); }
export function addMonths(dt: DateTime, n: number): DateTime { return add(dt, n, "month"); }
export function addWeeks(dt: DateTime, n: number): DateTime { return add(dt, n, "week"); }
export function addDays(dt: DateTime, n: number): DateTime { return add(dt, n, "day"); }
export function addHours(dt: DateTime, n: number): DateTime { return add(dt, n, "hour"); }
export function addMinutes(dt: DateTime, n: number): DateTime { return add(dt, n, "minute"); }
export function addSeconds(dt: DateTime, n: number): DateTime { return add(dt, n, "second"); }
export function addMilliseconds(dt: DateTime, n: number): DateTime { return add(dt, n, "millisecond"); }
export function addMicroseconds(dt: DateTime, n: number): DateTime { return add(dt, n, "microsecond"); }
export function addNanoseconds(dt: DateTime, n: number): DateTime { return add(dt, n, "nanosecond"); }

export function subtractYears(dt: DateTime, n: number): DateTime { return subtract(dt, n, "year"); }
export function subtractMonths(dt: DateTime, n: number): DateTime { return subtract(dt, n, "month"); }
export function subtractWeeks(dt: DateTime, n: number): DateTime { return subtract(dt, n, "week"); }
export function subtractDays(dt: DateTime, n: number): DateTime { return subtract(dt, n, "day"); }
export function subtractHours(dt: DateTime, n: number): DateTime { return subtract(dt, n, "hour"); }
export function subtractMinutes(dt: DateTime, n: number): DateTime { return subtract(dt, n, "minute"); }
export function subtractSeconds(dt: DateTime, n: number): DateTime { return subtract(dt, n, "second"); }

// startOf / endOf
export function startOfDay(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCHours(0, 0, 0, 0);
  return fromJSDate(d, dt.scale);
}

export function endOfDay(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCHours(23, 59, 59, 999);
  return fromJSDate(d, dt.scale);
}

export function startOfHour(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCMinutes(0, 0, 0);
  return fromJSDate(d, dt.scale);
}

export function endOfHour(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCMinutes(59, 59, 999);
  return fromJSDate(d, dt.scale);
}

export function startOfMinute(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCSeconds(0, 0);
  return fromJSDate(d, dt.scale);
}

export function endOfMinute(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCSeconds(59, 999);
  return fromJSDate(d, dt.scale);
}

export function startOfMonth(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCDate(1);
  d.setUTCHours(0, 0, 0, 0);
  return fromJSDate(d, dt.scale);
}

export function endOfMonth(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  d.setUTCMonth(d.getUTCMonth() + 1, 0);
  d.setUTCHours(23, 59, 59, 999);
  return fromJSDate(d, dt.scale);
}

export function startOfYear(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  return fromJSDate(new Date(Date.UTC(d.getUTCFullYear(), 0, 1)), dt.scale);
}

export function endOfYear(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  return fromJSDate(new Date(Date.UTC(d.getUTCFullYear(), 11, 31, 23, 59, 59, 999)), dt.scale);
}

export function startOfWeek(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  const dayOfWeek = d.getUTCDay();
  d.setUTCDate(d.getUTCDate() - dayOfWeek);
  d.setUTCHours(0, 0, 0, 0);
  return fromJSDate(d, dt.scale);
}

export function endOfWeek(dt: DateTime): DateTime {
  const d = toJSDate(dt);
  const dayOfWeek = d.getUTCDay();
  d.setUTCDate(d.getUTCDate() + (6 - dayOfWeek));
  d.setUTCHours(23, 59, 59, 999);
  return fromJSDate(d, dt.scale);
}

export function startOf(dt: DateTime, unit: TimeUnit): DateTime {
  switch (unit) {
    case "year": return startOfYear(dt);
    case "month": return startOfMonth(dt);
    case "week": return startOfWeek(dt);
    case "day": return startOfDay(dt);
    case "hour": return startOfHour(dt);
    case "minute": return startOfMinute(dt);
    default: return dt;
  }
}

export function endOf(dt: DateTime, unit: TimeUnit): DateTime {
  switch (unit) {
    case "year": return endOfYear(dt);
    case "month": return endOfMonth(dt);
    case "week": return endOfWeek(dt);
    case "day": return endOfDay(dt);
    case "hour": return endOfHour(dt);
    case "minute": return endOfMinute(dt);
    default: return dt;
  }
}
```

**Step 4: Run tests**

Run: `cd libraries/datetime && bun test __tests__/core/arithmetic.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add libraries/datetime/src/core/arithmetic.ts libraries/datetime/__tests__/core/arithmetic.test.ts
git commit -m "feat(datetime): add arithmetic functions (add, subtract, startOf, endOf)"
```

---

## Task 5: Core — Comparison and Diff

**Files:**
- Create: `libraries/datetime/src/core/comparison.ts`
- Test: `libraries/datetime/__tests__/core/comparison.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/core/comparison.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import {
  isBefore, isAfter, isSame, isSameOrBefore, isSameOrAfter,
  isBetween, diff,
} from "../../src/core/comparison";

const jan15 = datetime("2024-01-15T12:00:00Z");
const jan20 = datetime("2024-01-20T12:00:00Z");
const feb15 = datetime("2024-02-15T12:00:00Z");

describe("isBefore()", () => {
  test("returns true when a is before b", () => expect(isBefore(jan15, jan20)).toBe(true));
  test("returns false when a is after b", () => expect(isBefore(jan20, jan15)).toBe(false));
  test("returns false when equal", () => expect(isBefore(jan15, jan15)).toBe(false));
});

describe("isAfter()", () => {
  test("returns true when a is after b", () => expect(isAfter(jan20, jan15)).toBe(true));
  test("returns false when a is before b", () => expect(isAfter(jan15, jan20)).toBe(false));
});

describe("isSame()", () => {
  test("returns true for same timestamps", () => {
    const a = datetime("2024-01-15T12:00:00Z");
    const b = datetime("2024-01-15T12:00:00Z");
    expect(isSame(a, b)).toBe(true);
  });
  test("returns false for different timestamps", () => expect(isSame(jan15, jan20)).toBe(false));
  test("same with unit 'day'", () => {
    const a = datetime("2024-01-15T10:00:00Z");
    const b = datetime("2024-01-15T18:00:00Z");
    expect(isSame(a, b, "day")).toBe(true);
  });
  test("different days with unit 'day'", () => expect(isSame(jan15, jan20, "day")).toBe(false));
});

describe("isBetween()", () => {
  test("returns true when in range", () => {
    const mid = datetime("2024-01-17T12:00:00Z");
    expect(isBetween(mid, jan15, jan20)).toBe(true);
  });
  test("returns false when outside range", () => expect(isBetween(feb15, jan15, jan20)).toBe(false));
});

describe("diff()", () => {
  test("diff in days", () => expect(diff(jan15, jan20, "day")).toBe(-5));
  test("diff in days reversed", () => expect(diff(jan20, jan15, "day")).toBe(5));
  test("diff in months", () => expect(diff(jan15, feb15, "month")).toBe(-1));
  test("diff in hours", () => {
    const a = datetime("2024-01-15T10:00:00Z");
    const b = datetime("2024-01-15T14:00:00Z");
    expect(diff(a, b, "hour")).toBe(-4);
  });
});

describe("cross-scale comparison", () => {
  test("compares DateTime with different scales", () => {
    const ms = datetime("2024-01-15T12:00:00Z", { scale: 3 });
    const us = datetime("2024-01-15T12:00:00Z", { scale: 6 });
    expect(isSame(ms, us)).toBe(true);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd libraries/datetime && bun test __tests__/core/comparison.test.ts`
Expected: FAIL

**Step 3: Implement comparison functions**

```typescript
// libraries/datetime/src/core/comparison.ts
import type { DateTime, TimeUnit } from "../types";
import { alignScales, convertTimestamp } from "../utils/scale";
import { startOf } from "./arithmetic";

export function isBefore(a: DateTime, b: DateTime): boolean {
  const [aTs, bTs] = alignScales(a, b);
  return aTs < bTs;
}

export function isAfter(a: DateTime, b: DateTime): boolean {
  const [aTs, bTs] = alignScales(a, b);
  return aTs > bTs;
}

export function isSame(a: DateTime, b: DateTime, unit?: TimeUnit): boolean {
  if (unit) {
    const aStart = startOf(a, unit);
    const bStart = startOf(b, unit);
    const [aTs, bTs] = alignScales(aStart, bStart);
    return aTs === bTs;
  }
  const [aTs, bTs] = alignScales(a, b);
  return aTs === bTs;
}

export function isSameOrBefore(a: DateTime, b: DateTime): boolean {
  const [aTs, bTs] = alignScales(a, b);
  return aTs <= bTs;
}

export function isSameOrAfter(a: DateTime, b: DateTime): boolean {
  const [aTs, bTs] = alignScales(a, b);
  return aTs >= bTs;
}

export function isBetween(dt: DateTime, start: DateTime, end: DateTime): boolean {
  return isSameOrAfter(dt, start) && isSameOrBefore(dt, end);
}

export function diff(a: DateTime, b: DateTime, unit: TimeUnit = "millisecond"): number {
  const [aTs, bTs, scale] = alignScales(a, b);
  const rawDiff = aTs - bTs;

  // Convert to microseconds first for uniform calculation
  const usDiff = Number(convertTimestamp(rawDiff, scale, 6));

  switch (unit) {
    case "nanosecond": return Number(convertTimestamp(rawDiff, scale, 9));
    case "microsecond": return usDiff;
    case "millisecond": return Math.trunc(usDiff / 1000);
    case "second": return Math.trunc(usDiff / 1000000);
    case "minute": return Math.trunc(usDiff / 60000000);
    case "hour": return Math.trunc(usDiff / 3600000000);
    case "day": return Math.trunc(usDiff / 86400000000);
    case "week": return Math.trunc(usDiff / 604800000000);
    case "month": {
      // Calendar-aware month diff
      const msA = convertTimestamp(a.timestamp, a.scale, 3);
      const msB = convertTimestamp(b.timestamp, b.scale, 3);
      const dA = new Date(Number(msA));
      const dB = new Date(Number(msB));
      return (dA.getUTCFullYear() - dB.getUTCFullYear()) * 12 + (dA.getUTCMonth() - dB.getUTCMonth());
    }
    case "year": {
      const msA = convertTimestamp(a.timestamp, a.scale, 3);
      const msB = convertTimestamp(b.timestamp, b.scale, 3);
      return new Date(Number(msA)).getUTCFullYear() - new Date(Number(msB)).getUTCFullYear();
    }
    default: return Math.trunc(usDiff / 1000);
  }
}
```

**Step 4: Run tests**

Run: `cd libraries/datetime && bun test __tests__/core/comparison.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add libraries/datetime/src/core/comparison.ts libraries/datetime/__tests__/core/comparison.test.ts
git commit -m "feat(datetime): add comparison and diff functions"
```

---

## Task 6: Core — Conversion and Formatting

**Files:**
- Create: `libraries/datetime/src/core/conversion.ts`
- Create: `libraries/datetime/src/core/format.ts`
- Test: `libraries/datetime/__tests__/core/conversion.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/core/conversion.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import {
  toDate, toISO, toJSON, toUnix, toMilliseconds, toMicroseconds,
  toNanoseconds, toDatabase, valueOf, convertScale,
} from "../../src/core/conversion";
import { format } from "../../src/core/format";

const dt = datetime("2024-01-15T14:30:45.123Z");

describe("conversion functions", () => {
  test("toDate() returns native Date", () => {
    const d = toDate(dt);
    expect(d).toBeInstanceOf(Date);
    expect(d.toISOString()).toBe("2024-01-15T14:30:45.123Z");
  });

  test("toISO()", () => expect(toISO(dt)).toBe("2024-01-15T14:30:45.123Z"));
  test("toJSON()", () => expect(toJSON(dt)).toBe("2024-01-15T14:30:45.123Z"));

  test("toUnix() returns seconds", () => {
    expect(toUnix(dt)).toBe(1705329045n);
  });

  test("toMilliseconds()", () => {
    expect(toMilliseconds(dt)).toBe(1705329045123n);
  });

  test("toMicroseconds()", () => {
    expect(toMicroseconds(dt)).toBe(1705329045123000n);
  });

  test("valueOf()", () => {
    expect(valueOf(dt)).toBe(dt.timestamp);
  });

  test("toDatabase postgres", () => {
    const result = toDatabase(dt, "postgres");
    expect(typeof result).toBe("string");
    expect(result).toContain("2024-01-15");
  });
});

describe("convertScale()", () => {
  test("converts from microseconds to milliseconds", () => {
    const result = convertScale(dt, 3);
    expect(result.scale).toBe(3);
    expect(result.timestamp).toBe(1705329045123n);
  });

  test("converts from microseconds to nanoseconds", () => {
    const result = convertScale(dt, 9);
    expect(result.scale).toBe(9);
    expect(result.timestamp).toBe(1705329045123000000n);
  });
});

describe("format()", () => {
  test("formats YYYY-MM-DD", () => {
    expect(format(dt, "YYYY-MM-DD")).toBe("2024-01-15");
  });

  test("formats HH:mm:ss", () => {
    expect(format(dt, "HH:mm:ss")).toBe("14:30:45");
  });

  test("formats full datetime", () => {
    expect(format(dt, "YYYY-MM-DD HH:mm:ss")).toBe("2024-01-15 14:30:45");
  });

  test("handles escaped text in brackets", () => {
    expect(format(dt, "[Date:] YYYY-MM-DD")).toBe("Date: 2024-01-15");
  });
});
```

**Step 2: Implement conversions**

```typescript
// libraries/datetime/src/core/conversion.ts
import type { DateTime, DateTimeScale } from "../types";
import { convertTimestamp } from "../utils/scale";

export function toDate(dt: DateTime): Date {
  const ms = convertTimestamp(dt.timestamp, dt.scale, 3);
  return new Date(Number(ms));
}

export function toISO(dt: DateTime): string {
  return toDate(dt).toISOString();
}

export function toJSON(dt: DateTime): string {
  return toISO(dt);
}

export function toUnix(dt: DateTime): bigint {
  return convertTimestamp(dt.timestamp, dt.scale, 0);
}

export function toMilliseconds(dt: DateTime): bigint {
  return convertTimestamp(dt.timestamp, dt.scale, 3);
}

export function toMicroseconds(dt: DateTime): bigint {
  return convertTimestamp(dt.timestamp, dt.scale, 6);
}

export function toNanoseconds(dt: DateTime): bigint {
  return convertTimestamp(dt.timestamp, dt.scale, 9);
}

export function valueOf(dt: DateTime): bigint {
  return dt.timestamp;
}

export function convertScale(dt: DateTime, targetScale: DateTimeScale): DateTime {
  return {
    timestamp: convertTimestamp(dt.timestamp, dt.scale, targetScale),
    scale: targetScale,
  };
}

export function toDatabase(
  dt: DateTime,
  dbType: "postgres" | "mysql" | "oracle" = "postgres",
): string {
  return toISO(dt);
}
```

```typescript
// libraries/datetime/src/core/format.ts
import type { DateTime } from "../types";
import { year, month, day, hour, minute, second, millisecond, dayOfWeek } from "./getters";

const MONTH_NAMES = ["January","February","March","April","May","June","July","August","September","October","November","December"];
const MONTH_SHORT = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
const DAY_NAMES = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
const DAY_SHORT = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
const DAY_MIN = ["Su","Mo","Tu","We","Th","Fr","Sa"];

function pad(n: number, len: number): string {
  return n.toString().padStart(len, "0");
}

const TOKEN_REGEX = /\[([^\]]+)\]|YYYY|MMMM|MMM|MM|M|dddd|ddd|DD|dd|D|d|HH|hh|H|h|mm|m|ss|s|SSS|YY|A|a/g;

export function format(dt: DateTime, template: string): string {
  const y = year(dt);
  const mo = month(dt);
  const d = day(dt);
  const h = hour(dt);
  const mi = minute(dt);
  const s = second(dt);
  const ms = millisecond(dt);
  const dow = dayOfWeek(dt);

  return template.replace(TOKEN_REGEX, (match, escaped) => {
    if (escaped !== undefined) return escaped;
    switch (match) {
      case "YYYY": return y.toString();
      case "YY": return pad(y % 100, 2);
      case "MMMM": return MONTH_NAMES[mo - 1]!;
      case "MMM": return MONTH_SHORT[mo - 1]!;
      case "MM": return pad(mo, 2);
      case "M": return mo.toString();
      case "DD": return pad(d, 2);
      case "D": return d.toString();
      case "dddd": return DAY_NAMES[dow]!;
      case "ddd": return DAY_SHORT[dow]!;
      case "dd": return DAY_MIN[dow]!;
      case "d": return dow.toString();
      case "HH": return pad(h, 2);
      case "H": return h.toString();
      case "hh": return pad(h % 12 || 12, 2);
      case "h": return (h % 12 || 12).toString();
      case "mm": return pad(mi, 2);
      case "m": return mi.toString();
      case "ss": return pad(s, 2);
      case "s": return s.toString();
      case "SSS": return pad(ms, 3);
      case "A": return h >= 12 ? "PM" : "AM";
      case "a": return h >= 12 ? "pm" : "am";
      default: return match;
    }
  });
}
```

**Step 3: Run tests**

Run: `cd libraries/datetime && bun test __tests__/core/conversion.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add libraries/datetime/src/core/conversion.ts libraries/datetime/src/core/format.ts libraries/datetime/__tests__/core/conversion.test.ts
git commit -m "feat(datetime): add conversion and format functions"
```

---

## Task 7: Main Index + Package Configuration

**Files:**
- Modify: `libraries/datetime/src/index.ts`
- Modify: `libraries/datetime/fot.config.ts`
- Modify: `libraries/datetime/package.json`

**Step 1: Write the new index.ts**

```typescript
// libraries/datetime/src/index.ts

// Types
export type { DateTime, DateTimeScale, TimeUnit, DateInput, DateTimeOptions } from "./types";
export { DateTimeScales } from "./types";

// Schemas
export { DateTimeSchema, DateTimeScaleSchema, TimeUnitSchema, DateInputSchema } from "./schemas";

// Errors
export { InvalidDateError } from "./errors";

// Factory
export { datetime, now, fromDate, fromISO, fromUnix, fromDatabase } from "./core/factory";

// Getters
export {
  year, month, day, hour, minute, second, millisecond,
  microsecond, nanosecond, dayOfWeek, dayOfYear, weekOfYear,
  daysInMonth, daysInYear, isLeapYear, isValid,
} from "./core/getters";

// Arithmetic
export {
  add, subtract,
  addYears, addMonths, addWeeks, addDays, addHours, addMinutes,
  addSeconds, addMilliseconds, addMicroseconds, addNanoseconds,
  subtractYears, subtractMonths, subtractWeeks, subtractDays,
  subtractHours, subtractMinutes, subtractSeconds,
  startOf, endOf,
  startOfYear, startOfMonth, startOfWeek, startOfDay, startOfHour, startOfMinute,
  endOfYear, endOfMonth, endOfWeek, endOfDay, endOfHour, endOfMinute,
} from "./core/arithmetic";

// Comparison
export {
  isBefore, isAfter, isSame, isSameOrBefore, isSameOrAfter, isBetween, diff,
} from "./core/comparison";

// Conversion
export {
  toDate, toISO, toJSON, toUnix, toMilliseconds, toMicroseconds,
  toNanoseconds, valueOf, convertScale, toDatabase,
} from "./core/conversion";

// Format
export { format } from "./core/format";
```

**Step 2: Update fot.config.ts**

```typescript
// libraries/datetime/fot.config.ts
import { defineFotConfig } from "@f-o-t/config";

export default defineFotConfig({
  external: ["zod", "@f-o-t/bigint"],
  plugins: [
    "timezone",
    "format",
    "relative-time",
    "calendar",
    "duration",
    "business-days",
  ],
});
```

**Step 3: Update package.json**

Update `version` to `2.0.0`, add `@f-o-t/bigint` dependency, update exports for new plugin paths. Remove old class-based plugin exports and add new functional ones.

Key changes:
- `"version": "2.0.0"`
- Add `"@f-o-t/bigint": "^1.0.4"` to dependencies
- Update exports to include new plugins
- Add `"./plugins/calendar"`, `"./plugins/duration"` exports

**Step 4: Build and run all tests**

Run: `cd libraries/datetime && bun x --bun fot build && bun test`
Expected: All tests pass, build succeeds

**Step 5: Commit**

```bash
git add libraries/datetime/src/index.ts libraries/datetime/fot.config.ts libraries/datetime/package.json
git commit -m "feat(datetime): wire up v2 index, config, and package.json"
```

---

## Task 8: Timezone Plugin (Functional)

**Files:**
- Create: `libraries/datetime/src/plugins/timezone/index.ts`
- Test: `libraries/datetime/__tests__/plugins/timezone.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/plugins/timezone.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import { toTimezone, getTimezoneOffset, isValidTimezone, utc } from "../../src/plugins/timezone";

describe("timezone plugin", () => {
  test("isValidTimezone() for valid timezone", () => {
    expect(isValidTimezone("America/New_York")).toBe(true);
  });

  test("isValidTimezone() for invalid timezone", () => {
    expect(isValidTimezone("Invalid/Zone")).toBe(false);
  });

  test("toTimezone() formats in target timezone", () => {
    const dt = datetime("2024-01-15T12:00:00Z");
    const result = toTimezone(dt, "America/New_York");
    expect(result).toContain("07:00"); // EST = UTC-5
  });

  test("getTimezoneOffset() returns offset in minutes", () => {
    const dt = datetime("2024-01-15T12:00:00Z");
    const offset = getTimezoneOffset(dt, "America/New_York");
    expect(offset).toBe(-300); // -5 hours = -300 minutes
  });

  test("utc() returns UTC formatted string", () => {
    const dt = datetime("2024-01-15T12:00:00Z");
    expect(utc(dt)).toContain("12:00");
  });
});
```

**Step 2: Implement timezone plugin**

```typescript
// libraries/datetime/src/plugins/timezone/index.ts
import type { DateTime } from "../../types";
import { toDate } from "../../core/conversion";
import { format } from "../../core/format";

export function isValidTimezone(tz: string): boolean {
  try {
    new Intl.DateTimeFormat("en-US", { timeZone: tz });
    return true;
  } catch {
    return false;
  }
}

export function toTimezone(dt: DateTime, timezone: string): string {
  if (!isValidTimezone(timezone)) {
    throw new Error(`Invalid timezone: ${timezone}`);
  }
  const d = toDate(dt);
  return d.toLocaleString("en-US", { timeZone: timezone, hour12: false });
}

export function getTimezoneOffset(dt: DateTime, timezone: string): number {
  if (!isValidTimezone(timezone)) {
    throw new Error(`Invalid timezone: ${timezone}`);
  }
  const d = toDate(dt);
  const utcStr = d.toLocaleString("en-US", { timeZone: "UTC" });
  const tzStr = d.toLocaleString("en-US", { timeZone: timezone });
  const utcDate = new Date(utcStr);
  const tzDate = new Date(tzStr);
  return (tzDate.getTime() - utcDate.getTime()) / 60000;
}

export function formatWithTimezone(
  dt: DateTime,
  template: string,
  timezone: string,
): string {
  if (!isValidTimezone(timezone)) {
    throw new Error(`Invalid timezone: ${timezone}`);
  }
  const d = toDate(dt);
  // Create a new date adjusted to the target timezone
  const offset = getTimezoneOffset(dt, timezone);
  const adjusted = new Date(d.getTime() + offset * 60000);
  // Use the adjusted date for formatting
  const { datetime: dtFactory } = require("../../core/factory");
  const adjustedDt = dtFactory(adjusted, { scale: dt.scale });
  return format(adjustedDt, template);
}

export function utc(dt: DateTime): string {
  return toTimezone(dt, "UTC");
}

export function getLocalTimezone(): string {
  return Intl.DateTimeFormat().resolvedOptions().timeZone;
}
```

**Step 3: Run tests**

Run: `cd libraries/datetime && bun test __tests__/plugins/timezone.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add libraries/datetime/src/plugins/timezone/ libraries/datetime/__tests__/plugins/timezone.test.ts
git commit -m "feat(datetime): add functional timezone plugin"
```

---

## Task 9: Relative Time Plugin (Functional)

**Files:**
- Create: `libraries/datetime/src/plugins/relative-time/index.ts`
- Test: `libraries/datetime/__tests__/plugins/relative-time.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/plugins/relative-time.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import { subtractHours, subtractDays, addHours } from "../../src/core/arithmetic";
import { fromNow, toNow, from, to } from "../../src/plugins/relative-time";

describe("relative-time plugin", () => {
  test("fromNow() past", () => {
    const dt = subtractHours(datetime(), 2);
    expect(fromNow(dt)).toContain("ago");
  });

  test("fromNow() future", () => {
    const dt = addHours(datetime(), 2);
    expect(fromNow(dt)).toContain("in");
  });

  test("from() calculates relative to another DateTime", () => {
    const a = datetime("2024-01-15T12:00:00Z");
    const b = datetime("2024-01-15T14:00:00Z");
    const result = from(a, b);
    expect(result).toContain("2");
    expect(result).toContain("hour");
  });
});
```

**Step 2: Implement relative-time plugin**

```typescript
// libraries/datetime/src/plugins/relative-time/index.ts
import type { DateTime } from "../../types";
import { now } from "../../core/factory";
import { diff } from "../../core/comparison";

const THRESHOLDS = {
  second: 45,
  minute: 90,
  hour: 2700,
  day: 75600,
  month: 2592000,
  year: 31536000,
};

function formatRelative(diffSeconds: number, isPast: boolean): string {
  const abs = Math.abs(diffSeconds);

  if (abs < THRESHOLDS.second) {
    return isPast ? "a few seconds ago" : "in a few seconds";
  }
  if (abs < THRESHOLDS.minute) {
    return isPast ? "a minute ago" : "in a minute";
  }
  if (abs < THRESHOLDS.hour) {
    const v = Math.round(abs / 60);
    const u = v === 1 ? "minute" : "minutes";
    return isPast ? `${v} ${u} ago` : `in ${v} ${u}`;
  }
  if (abs < THRESHOLDS.day) {
    const v = Math.round(abs / 3600);
    if (v === 1) return isPast ? "an hour ago" : "in an hour";
    return isPast ? `${v} hours ago` : `in ${v} hours`;
  }
  if (abs < THRESHOLDS.month) {
    const v = Math.round(abs / 86400);
    if (v === 1) return isPast ? "a day ago" : "in a day";
    return isPast ? `${v} days ago` : `in ${v} days`;
  }
  if (abs < THRESHOLDS.year) {
    const v = Math.round(abs / 2592000);
    if (v === 1) return isPast ? "a month ago" : "in a month";
    return isPast ? `${v} months ago` : `in ${v} months`;
  }
  const v = Math.round(abs / 31536000);
  if (v === 1) return isPast ? "a year ago" : "in a year";
  return isPast ? `${v} years ago` : `in ${v} years`;
}

export function fromNow(dt: DateTime): string {
  const diffSec = diff(dt, now(dt.scale), "second");
  return formatRelative(diffSec, diffSec < 0);
}

export function toNow(dt: DateTime): string {
  const diffSec = diff(dt, now(dt.scale), "second");
  return formatRelative(diffSec, diffSec > 0);
}

export function from(dt: DateTime, other: DateTime): string {
  const diffSec = diff(dt, other, "second");
  return formatRelative(diffSec, diffSec < 0);
}

export function to(dt: DateTime, other: DateTime): string {
  const diffSec = diff(dt, other, "second");
  return formatRelative(diffSec, diffSec > 0);
}
```

**Step 3: Run tests, commit**

Run: `cd libraries/datetime && bun test __tests__/plugins/relative-time.test.ts`

```bash
git add libraries/datetime/src/plugins/relative-time/ libraries/datetime/__tests__/plugins/relative-time.test.ts
git commit -m "feat(datetime): add functional relative-time plugin"
```

---

## Task 10: Business Days Plugin (Functional)

**Files:**
- Create: `libraries/datetime/src/plugins/business-days/index.ts`
- Test: `libraries/datetime/__tests__/plugins/business-days.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/plugins/business-days.test.ts
import { describe, expect, test } from "bun:test";
import { datetime } from "../../src/core/factory";
import { isWeekday, isWeekend, addBusinessDays, businessDaysBetween } from "../../src/plugins/business-days";

describe("business-days plugin", () => {
  test("Monday is weekday", () => {
    expect(isWeekday(datetime("2024-01-15T12:00:00Z"))).toBe(true); // Monday
  });

  test("Saturday is weekend", () => {
    expect(isWeekend(datetime("2024-01-13T12:00:00Z"))).toBe(true); // Saturday
  });

  test("addBusinessDays() skips weekends", () => {
    const friday = datetime("2024-01-12T12:00:00Z"); // Friday
    const result = addBusinessDays(friday, 1);
    // Should be Monday Jan 15
    expect(result.timestamp).toBe(datetime("2024-01-15T12:00:00Z").timestamp);
  });

  test("businessDaysBetween()", () => {
    const mon = datetime("2024-01-15T12:00:00Z");
    const fri = datetime("2024-01-19T12:00:00Z");
    expect(businessDaysBetween(mon, fri)).toBe(4);
  });
});
```

**Step 2: Implement business-days plugin**

```typescript
// libraries/datetime/src/plugins/business-days/index.ts
import type { DateTime } from "../../types";
import { dayOfWeek } from "../../core/getters";
import { addDays } from "../../core/arithmetic";
import { isBefore, isSame } from "../../core/comparison";
import { startOfDay } from "../../core/arithmetic";

export function isWeekday(dt: DateTime): boolean {
  const dow = dayOfWeek(dt);
  return dow >= 1 && dow <= 5;
}

export function isWeekend(dt: DateTime): boolean {
  const dow = dayOfWeek(dt);
  return dow === 0 || dow === 6;
}

export function addBusinessDays(dt: DateTime, n: number): DateTime {
  let current = dt;
  let remaining = Math.abs(n);
  const direction = n >= 0 ? 1 : -1;

  while (remaining > 0) {
    current = addDays(current, direction);
    if (isWeekday(current)) {
      remaining--;
    }
  }
  return current;
}

export function subtractBusinessDays(dt: DateTime, n: number): DateTime {
  return addBusinessDays(dt, -n);
}

export function businessDaysBetween(start: DateTime, end: DateTime): number {
  let count = 0;
  let current = startOfDay(start);
  const target = startOfDay(end);

  while (isBefore(current, target)) {
    if (isWeekday(current)) count++;
    current = addDays(current, 1);
  }
  return count;
}
```

**Step 3: Run tests, commit**

Run: `cd libraries/datetime && bun test __tests__/plugins/business-days.test.ts`

```bash
git add libraries/datetime/src/plugins/business-days/ libraries/datetime/__tests__/plugins/business-days.test.ts
git commit -m "feat(datetime): add functional business-days plugin"
```

---

## Task 11: Duration Plugin (Functional)

**Files:**
- Create: `libraries/datetime/src/plugins/duration/index.ts`
- Test: `libraries/datetime/__tests__/plugins/duration.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/datetime/__tests__/plugins/duration.test.ts
import { describe, expect, test } from "bun:test";
import { duration, humanize, asHours, asMinutes, asSeconds } from "../../src/plugins/duration";

describe("duration plugin", () => {
  test("duration() creates Duration object", () => {
    const d = duration(3661, "second");
    expect(d.value).toBe(3661);
    expect(d.unit).toBe("second");
  });

  test("humanize()", () => {
    expect(humanize(duration(2, "hour"))).toBe("2 hours");
    expect(humanize(duration(1, "day"))).toBe("a day");
    expect(humanize(duration(30, "minute"))).toBe("30 minutes");
  });

  test("asHours()", () => {
    expect(asHours(duration(120, "minute"))).toBe(2);
  });

  test("asMinutes()", () => {
    expect(asMinutes(duration(2, "hour"))).toBe(120);
  });

  test("asSeconds()", () => {
    expect(asSeconds(duration(1, "minute"))).toBe(60);
  });
});
```

**Step 2: Implement duration plugin**

```typescript
// libraries/datetime/src/plugins/duration/index.ts
import type { TimeUnit } from "../../types";

export type Duration = {
  readonly value: number;
  readonly unit: TimeUnit;
};

const SECONDS_MAP: Partial<Record<TimeUnit, number>> = {
  nanosecond: 1e-9,
  microsecond: 1e-6,
  millisecond: 0.001,
  second: 1,
  minute: 60,
  hour: 3600,
  day: 86400,
  week: 604800,
};

export function duration(value: number, unit: TimeUnit): Duration {
  return { value, unit };
}

function toSeconds(d: Duration): number {
  return d.value * (SECONDS_MAP[d.unit] ?? 0);
}

export function humanize(d: Duration): string {
  const sec = Math.abs(toSeconds(d));
  if (sec < 60) return sec === 1 ? "a second" : `${Math.round(sec)} seconds`;
  if (sec < 3600) {
    const m = Math.round(sec / 60);
    return m === 1 ? "a minute" : `${m} minutes`;
  }
  if (sec < 86400) {
    const h = Math.round(sec / 3600);
    return h === 1 ? "an hour" : `${h} hours`;
  }
  if (sec < 2592000) {
    const days = Math.round(sec / 86400);
    return days === 1 ? "a day" : `${days} days`;
  }
  if (sec < 31536000) {
    const months = Math.round(sec / 2592000);
    return months === 1 ? "a month" : `${months} months`;
  }
  const years = Math.round(sec / 31536000);
  return years === 1 ? "a year" : `${years} years`;
}

export function asSeconds(d: Duration): number { return toSeconds(d); }
export function asMinutes(d: Duration): number { return toSeconds(d) / 60; }
export function asHours(d: Duration): number { return toSeconds(d) / 3600; }
export function asDays(d: Duration): number { return toSeconds(d) / 86400; }
export function asWeeks(d: Duration): number { return toSeconds(d) / 604800; }
```

**Step 3: Run tests, commit**

Run: `cd libraries/datetime && bun test __tests__/plugins/duration.test.ts`

```bash
git add libraries/datetime/src/plugins/duration/ libraries/datetime/__tests__/plugins/duration.test.ts
git commit -m "feat(datetime): add functional duration plugin"
```

---

## Task 12: Calendar Plugin (Functional)

**Files:**
- Create: `libraries/datetime/src/plugins/calendar/index.ts`
- Test: `libraries/datetime/__tests__/plugins/calendar.test.ts`

**Step 1: Write tests, implement, commit**

The calendar plugin exports `calendar(dt)` which returns strings like "Today at 2:30 PM", "Yesterday at 10:00 AM", "Last Friday at 3:00 PM", or "01/15/2024".

```typescript
// libraries/datetime/src/plugins/calendar/index.ts
import type { DateTime } from "../../types";
import { now } from "../../core/factory";
import { diff } from "../../core/comparison";
import { format } from "../../core/format";
import { dayOfWeek } from "../../core/getters";

const DAY_NAMES = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];

export function calendar(dt: DateTime, reference?: DateTime): string {
  const ref = reference ?? now(dt.scale);
  const dayDiff = diff(dt, ref, "day");
  const timeStr = format(dt, "h:mm A");

  if (dayDiff === 0) return `Today at ${timeStr}`;
  if (dayDiff === -1) return `Yesterday at ${timeStr}`;
  if (dayDiff === 1) return `Tomorrow at ${timeStr}`;
  if (dayDiff > -7 && dayDiff < 0) return `Last ${DAY_NAMES[dayOfWeek(dt)]} at ${timeStr}`;
  if (dayDiff > 0 && dayDiff < 7) return `${DAY_NAMES[dayOfWeek(dt)]} at ${timeStr}`;
  return format(dt, "MM/DD/YYYY");
}
```

Run: `cd libraries/datetime && bun test __tests__/plugins/calendar.test.ts`

```bash
git add libraries/datetime/src/plugins/calendar/ libraries/datetime/__tests__/plugins/calendar.test.ts
git commit -m "feat(datetime): add functional calendar plugin"
```

---

## Task 13: Delete Old Class-Based Code + Documentation

**Files:**
- Delete: `libraries/datetime/src/core/datetime.ts` (old 694-line class)
- Delete: `libraries/datetime/src/core/factory.ts` (old wrapper)
- Delete: `libraries/datetime/src/plugins/plugin-base.ts`
- Delete: `libraries/datetime/src/plugins/index.ts` (old plugin exports)
- Update: `libraries/datetime/README.md`
- Update: `libraries/datetime/CHANGELOG.md`
- Create: `libraries/datetime/.npmignore`

**Step 1: Remove old class-based files**

Delete the old DateTime class and class-based plugin system. The new functional code in `src/core/` and `src/plugins/` replaces everything.

**Step 2: Write README.md**

Complete rewrite showing functional API usage, bigint precision, plugin imports, and database compatibility.

**Step 3: Update CHANGELOG.md**

```markdown
## [2.0.0] - 2026-02-XX

### Changed
- BREAKING: Refactored entire API from class-based to functional approach
- BREAKING: DateTime is now a plain type `{ timestamp: bigint, scale: DateTimeScale }`, not a class
- BREAKING: All operations are pure functions, not instance methods
- BREAKING: Default precision changed from milliseconds to microseconds (scale 6)
- BREAKING: Plugins are now subpath exports of pure functions, not class extensions

### Added
- High-precision bigint timestamps (microseconds, nanoseconds) via @f-o-t/bigint
- Database compatibility (PostgreSQL, MySQL, Oracle) with `fromDatabase()` / `toDatabase()`
- Scale conversion utilities (`convertScale()`)
- Calendar plugin with `calendar()` function
- Duration plugin with `duration()`, `humanize()`, conversion functions
- Microsecond/nanosecond getters
- `fromDatabase()` and `toDatabase()` factory/conversion functions

### Removed
- DateTime class
- Class-based plugin system (`extend()`, `createPlugin()`)
- `declare module` TypeScript augmentation pattern
```

**Step 4: Ensure .npmignore exists**

```
src/
__tests__/
*.test.ts
tsconfig.json
fot.config.ts
biome.json
.turbo
```

**Step 5: Build and run all tests**

Run: `cd libraries/datetime && bun x --bun fot build && bun test`
Expected: All tests pass, build succeeds

**Step 6: Commit**

```bash
git add -A libraries/datetime/
git commit -m "feat(datetime): complete v2.0.0 refactor — functional API with bigint precision

BREAKING CHANGE: DateTime is now a plain type, not a class.
All operations are pure functions. Default scale is microseconds."
```

---

## Task 14-23: Library Migrations

Each migration follows the same pattern. Here's the template, then specific details per library.

### Migration Template

For each library:

1. Add `@f-o-t/datetime` dependency to `package.json`
2. Add `@f-o-t/datetime` to `external` in `fot.config.ts`
3. Replace `new Date()` with `datetime()` or `now()`
4. Replace `Date` types with `DateTime` from `@f-o-t/datetime`
5. Replace `z.date()` with `DateTimeSchema`
6. Use functional comparison/arithmetic functions
7. Update tests
8. Update CHANGELOG
9. Version bump
10. Build and test

---

### Task 14: Migrate @f-o-t/digital-certificate

**Files to modify:**
- `libraries/digital-certificate/package.json` — add `@f-o-t/datetime` dep
- `libraries/digital-certificate/fot.config.ts` — add to external
- `libraries/digital-certificate/src/types.ts` — `Date` → `DateTime`
- `libraries/digital-certificate/src/certificate.ts` — use datetime functions
- `libraries/digital-certificate/src/x509.ts` — `parseTime()` returns DateTime
- `libraries/digital-certificate/CHANGELOG.md`

**Key changes in certificate.ts:**

```typescript
// Before:
export function daysUntilExpiry(cert: CertificateInfo): number {
  const now = new Date();
  const diff = cert.validity.notAfter.getTime() - now.getTime();
  return Math.floor(diff / (1000 * 60 * 60 * 24));
}

// After:
import { now as dtNow, diff } from "@f-o-t/datetime";

export function daysUntilExpiry(cert: CertificateInfo): number {
  return diff(dtNow(), cert.validity.notAfter, "day");
}
```

```typescript
// Before:
function checkValidity(validity: CertificateValidity): boolean {
  const now = new Date();
  return now >= validity.notBefore && now <= validity.notAfter;
}

// After:
import { now as dtNow, isBetween } from "@f-o-t/datetime";

function checkValidity(validity: CertificateValidity): boolean {
  return isBetween(dtNow(), validity.notBefore, validity.notAfter);
}
```

**Version bump:** Current → next major (breaking: Date → DateTime in public types)

---

### Task 15: Migrate @f-o-t/condition-evaluator

**Files to modify:**
- `libraries/condition-evaluator/src/operators/date.ts` — complete refactor

**Key changes:**

```typescript
// Before:
function toDate(value: DateValue): Date {
  if (value instanceof Date) return value;
  return new Date(value);
}

// After:
import { datetime, isBefore, isAfter, isBetween, dayOfWeek, day } from "@f-o-t/datetime";
import type { DateTime } from "@f-o-t/datetime";

function toDateTime(value: unknown): DateTime {
  return datetime(value as any);
}
```

Replace all operators to use functional datetime API.

---

### Task 16: Migrate @f-o-t/rules-engine

**Files to modify (many):**
- `src/types/rule.ts` — `z.date()` → `DateTimeSchema`, `Date` → `DateTime`
- `src/types/evaluation.ts` — `timestamp: Date` → `DateTime`
- `src/types/state.ts` — `lastEvaluated?: Date` → `DateTime`
- `src/serialization/serializer.ts` — `new Date()` → `datetime()`, `.toISOString()` → `toISO()`
- `src/cache/cache.ts` — `Date.now()` → can keep as-is (internal cache timing)
- `src/versioning/version-store.ts` — `createdAt: Date` → `DateTime`

This is the largest migration. Version bump to next major.

---

### Task 17: Migrate @f-o-t/ofx

**Files to modify:**
- `src/utils.ts` — `formatOfxDate()` uses datetime format
- `src/generator.ts` — `z.date()` schemas → `DateTimeSchema`

---

### Task 18: Migrate @f-o-t/pdf

**Files:** `src/types.ts` — `creationDate?: Date` → `DateTime`

---

### Task 19: Migrate @f-o-t/e-signature

Depends on digital-certificate migration (Task 14). Update any timestamp types.

---

### Task 20: Migrate @f-o-t/content-analysis

Simple: `new Date().toISOString()` → `toISO(now())`

---

### Task 21: Migrate @f-o-t/spelling

`Date.now()` for TTL — can keep as-is since it's internal cache timing, not a public API.

---

### Task 22: Migrate @f-o-t/csv

`value instanceof Date` checks in generator — add `DateTime` handling alongside.

---

### Task 23: Migrate @f-o-t/brasil-api

String timestamps only — no migration needed. Remove from migration list.

---

## Task 24: Final Integration Test + Release

**Step 1: Build all migrated libraries**

```bash
cd libraries/datetime && bun x --bun fot build
cd libraries/digital-certificate && bun x --bun fot build
cd libraries/condition-evaluator && bun x --bun fot build
cd libraries/rules-engine && bun x --bun fot build
cd libraries/ofx && bun x --bun fot build
cd libraries/pdf && bun x --bun fot build
```

**Step 2: Run all tests**

```bash
cd libraries/datetime && bun test
cd libraries/digital-certificate && bun test
cd libraries/condition-evaluator && bun test
cd libraries/rules-engine && bun test
```

**Step 3: Final commit and push**

```bash
git push origin master
```

GitHub CI handles npm publishing automatically.
