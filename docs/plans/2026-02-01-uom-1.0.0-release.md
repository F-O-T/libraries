# @f-o-t/uom 1.0.0 Release Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Release @f-o-t/uom version 1.0.0 as a production-ready, stable units of measurement library with comprehensive documentation, arithmetic operations, condition-evaluator integration, and a frozen public API.

**Architecture:** Add measurement arithmetic operations (convert, add, subtract, multiply, divide) using @f-o-t/bigint primitives, create condition-evaluator operators plugin for measurement comparisons, enhance README with complete API documentation and examples, and stabilize the public API for semver commitment.

**Tech Stack:** @f-o-t/bigint ^1.0.0, @f-o-t/condition-evaluator ^0.1.0 (peer), Zod ^4.3.6, TypeScript

---

## Benefits

- **Complete API**: All essential measurement operations (convert, add, subtract, multiply, divide)
- **Condition Integration**: Seamless integration with @f-o-t/condition-evaluator for business rules
- **Production Ready**: Comprehensive documentation, stable API, full test coverage
- **Semver Commitment**: 1.0.0 signals API stability and commitment to semantic versioning
- **Developer Experience**: Clear examples, type safety, predictable behavior

## Pre-Release Checklist

- [ ] Current version is 0.2.0
- [ ] All tests passing (73 tests)
- [ ] @f-o-t/bigint 1.0.0 is available
- [ ] @f-o-t/condition-evaluator is available (for operators plugin)

## Release Tasks

### Task 1: Add Measurement Conversion Operation

**Files:**
- Create: `libraries/uom/src/operations/convert.ts`
- Modify: `libraries/uom/src/index.ts`
- Create: `libraries/uom/__tests__/convert.test.ts`

**Step 1: Write failing test for basic conversion**

Create `libraries/uom/__tests__/convert.test.ts`:
```typescript
import { describe, expect, test } from "bun:test";
import { convert, of } from "../src/index";

describe("convert", () => {
   test("converts kg to lbs", () => {
      const kg = of(10, "kg");
      const lbs = convert(kg, "lbs");

      expect(lbs.unit).toBe("lbs");
      expect(lbs.scale).toBe(12);
      // 10 kg = 22.046226218 lbs
      // At scale 12: 22046226218000n
      expect(lbs.value).toBe(22046226218000n);
   });
});
```

**Step 2: Run test to verify it fails**

Run: `cd libraries/uom && bun test __tests__/convert.test.ts`
Expected: FAIL with "convert is not defined"

**Step 3: Implement convert function**

Create `libraries/uom/src/operations/convert.ts`:
```typescript
import { divide, multiply } from "@f-o-t/bigint";
import { ConversionError } from "../errors";
import type { Measurement } from "../types/measurement";
import type { UnitSymbol } from "../types/units";
import { getUnit } from "../units/registry";
import { fromBaseUnits } from "../core/measurement";

/**
 * Convert a measurement to a different unit within the same category
 *
 * @param measurement - The measurement to convert
 * @param targetUnit - The target unit symbol
 * @returns A new measurement in the target unit
 * @throws {ConversionError} If units are in different categories
 * @throws {InvalidMeasurementError} If target unit is unknown
 *
 * @example
 * ```typescript
 * const kg = of(10, "kg");
 * const lbs = convert(kg, "lbs"); // 22.046226218 lbs
 * ```
 */
export function convert(
   measurement: Measurement,
   targetUnit: UnitSymbol,
): Measurement {
   const sourceUnitDef = getUnit(measurement.unit);
   const targetUnitDef = getUnit(targetUnit);

   if (!sourceUnitDef || !targetUnitDef) {
      throw new ConversionError(
         `Cannot convert: unknown unit (${measurement.unit} or ${targetUnit})`,
      );
   }

   if (sourceUnitDef.category !== targetUnitDef.category) {
      throw new ConversionError(
         `Cannot convert ${measurement.unit} (${sourceUnitDef.category}) to ${targetUnit} (${targetUnitDef.category})`,
      );
   }

   // Same unit, just return a copy
   if (measurement.unit === targetUnit) {
      return { ...measurement };
   }

   // Convert to base units
   const inBaseUnits = multiply({
      a: measurement.value,
      b: sourceUnitDef.toBaseMultiplier,
      scale: measurement.scale,
   });

   // Convert from base units to target
   const inTargetUnits = divide({
      dividend: inBaseUnits,
      divisor: targetUnitDef.toBaseMultiplier,
      scale: measurement.scale,
   });

   return fromBaseUnits(inTargetUnits, targetUnit, measurement.scale);
}
```

**Step 4: Export convert function**

Modify `libraries/uom/src/index.ts` - add after measurement exports:
```typescript
// Export operations
export { convert } from "./operations/convert";
```

**Step 5: Run test to verify basic conversion passes**

Run: `cd libraries/uom && bun test __tests__/convert.test.ts`
Expected: 1 test PASS

**Step 6: Add comprehensive conversion tests**

Add to `libraries/uom/__tests__/convert.test.ts`:
```typescript
test("converts meters to kilometers", () => {
   const meters = of(1000, "m");
   const km = convert(meters, "km");

   expect(km.unit).toBe("km");
   expect(km.value).toBe(1_000_000_000_000n); // 1.0 at scale 12
});

test("converts liters to milliliters", () => {
   const liters = of(2.5, "L");
   const ml = convert(liters, "mL");

   expect(ml.unit).toBe("mL");
   expect(ml.value).toBe(2500_000_000_000_000n); // 2500.0 at scale 12
});

test("converts celsius to fahrenheit", () => {
   const celsius = of(100, "°C");
   const fahrenheit = convert(celsius, "°F");

   expect(fahrenheit.unit).toBe("°F");
   // 100°C = 212°F
   expect(fahrenheit.value).toBe(212_000_000_000_000n);
});

test("same unit returns copy", () => {
   const original = of(10, "kg");
   const copy = convert(original, "kg");

   expect(copy).toEqual(original);
   expect(copy).not.toBe(original); // Different object
});

test("throws ConversionError for different categories", () => {
   const weight = of(10, "kg");

   expect(() => convert(weight, "m")).toThrow(ConversionError);
   expect(() => convert(weight, "m")).toThrow("Cannot convert kg (weight) to m (length)");
});

test("throws for unknown target unit", () => {
   const weight = of(10, "kg");

   expect(() => convert(weight, "unknown" as any)).toThrow();
});
```

**Step 7: Run full test suite**

Run: `cd libraries/uom && bun test`
Expected: All tests PASS (should be ~80+ tests now)

**Step 8: Commit**

```bash
git add libraries/uom/src/operations/convert.ts libraries/uom/__tests__/convert.test.ts libraries/uom/src/index.ts
git commit -m "feat(uom): add convert() operation for unit conversion

Add convert function to change measurements between units in the same category.
Supports all unit categories (weight, length, volume, area, temperature).

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 2: Add Measurement Arithmetic Operations

**Files:**
- Create: `libraries/uom/src/operations/arithmetic.ts`
- Modify: `libraries/uom/src/index.ts`
- Create: `libraries/uom/__tests__/arithmetic.test.ts`

**Step 1: Write failing tests for arithmetic operations**

Create `libraries/uom/__tests__/arithmetic.test.ts`:
```typescript
import { describe, expect, test } from "bun:test";
import { add, divide, multiply, of, subtract } from "../src/index";

describe("add", () => {
   test("adds measurements with same unit", () => {
      const a = of(10, "kg");
      const b = of(5, "kg");
      const result = add(a, b);

      expect(result.value).toBe(15_000_000_000_000n);
      expect(result.unit).toBe("kg");
   });
});

describe("subtract", () => {
   test("subtracts measurements with same unit", () => {
      const a = of(10, "kg");
      const b = of(3, "kg");
      const result = subtract(a, b);

      expect(result.value).toBe(7_000_000_000_000n);
      expect(result.unit).toBe("kg");
   });
});

describe("multiply", () => {
   test("multiplies measurement by scalar", () => {
      const measurement = of(10, "kg");
      const result = multiply(measurement, 2.5);

      expect(result.value).toBe(25_000_000_000_000n);
      expect(result.unit).toBe("kg");
   });
});

describe("divide", () => {
   test("divides measurement by scalar", () => {
      const measurement = of(10, "kg");
      const result = divide(measurement, 2);

      expect(result.value).toBe(5_000_000_000_000n);
      expect(result.unit).toBe("kg");
   });
});
```

**Step 2: Run test to verify it fails**

Run: `cd libraries/uom && bun test __tests__/arithmetic.test.ts`
Expected: FAIL with "add is not defined"

**Step 3: Implement arithmetic operations**

Create `libraries/uom/src/operations/arithmetic.ts`:
```typescript
import {
   add as bigintAdd,
   divide as bigintDivide,
   multiply as bigintMultiply,
   subtract as bigintSubtract,
} from "@f-o-t/bigint";
import { UnitMismatchError } from "../errors";
import { fromBaseUnits } from "../core/measurement";
import { parseDecimalToBigInt } from "../utils/precision";
import type { Measurement } from "../types/measurement";

/**
 * Add two measurements with compatible units
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns New measurement with sum
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * const total = add(of(10, "kg"), of(5, "kg")); // 15 kg
 * ```
 */
export function add(a: Measurement, b: Measurement): Measurement {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot add ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot add measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   const sum = bigintAdd({
      a: a.value,
      b: b.value,
      scale: a.scale,
   });

   return fromBaseUnits(sum, a.unit, a.scale);
}

/**
 * Subtract two measurements with compatible units
 *
 * @param a - First measurement (minuend)
 * @param b - Second measurement (subtrahend)
 * @returns New measurement with difference
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * const remaining = subtract(of(10, "kg"), of(3, "kg")); // 7 kg
 * ```
 */
export function subtract(a: Measurement, b: Measurement): Measurement {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot subtract ${b.unit} from ${a.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot subtract measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   const difference = bigintSubtract({
      a: a.value,
      b: b.value,
      scale: a.scale,
   });

   return fromBaseUnits(difference, a.unit, a.scale);
}

/**
 * Multiply a measurement by a scalar value
 *
 * @param measurement - The measurement to multiply
 * @param scalar - The scalar multiplier (number or string)
 * @returns New measurement with product
 *
 * @example
 * ```typescript
 * const doubled = multiply(of(10, "kg"), 2); // 20 kg
 * const tripled = multiply(of(5, "m"), "3.5"); // 17.5 m
 * ```
 */
export function multiply(
   measurement: Measurement,
   scalar: number | string,
): Measurement {
   const scalarBigInt = parseDecimalToBigInt(scalar, measurement.scale);

   const product = bigintMultiply({
      a: measurement.value,
      b: scalarBigInt,
      scale: measurement.scale,
   });

   return fromBaseUnits(product, measurement.unit, measurement.scale);
}

/**
 * Divide a measurement by a scalar value
 *
 * @param measurement - The measurement to divide
 * @param scalar - The scalar divisor (number or string)
 * @returns New measurement with quotient
 *
 * @example
 * ```typescript
 * const half = divide(of(10, "kg"), 2); // 5 kg
 * const third = divide(of(9, "m"), 3); // 3 m
 * ```
 */
export function divide(
   measurement: Measurement,
   scalar: number | string,
): Measurement {
   const scalarBigInt = parseDecimalToBigInt(scalar, measurement.scale);

   const quotient = bigintDivide({
      dividend: measurement.value,
      divisor: scalarBigInt,
      scale: measurement.scale,
   });

   return fromBaseUnits(quotient, measurement.unit, measurement.scale);
}
```

**Step 4: Export arithmetic operations**

Modify `libraries/uom/src/index.ts` - add to operations exports:
```typescript
export { add, divide, multiply, subtract } from "./operations/arithmetic";
```

**Step 5: Run test to verify basic operations pass**

Run: `cd libraries/uom && bun test __tests__/arithmetic.test.ts`
Expected: 4 tests PASS

**Step 6: Add comprehensive arithmetic tests**

Add to `libraries/uom/__tests__/arithmetic.test.ts`:
```typescript
describe("add - edge cases", () => {
   test("throws UnitMismatchError for different units", () => {
      const kg = of(10, "kg");
      const lbs = of(5, "lbs");

      expect(() => add(kg, lbs)).toThrow(UnitMismatchError);
      expect(() => add(kg, lbs)).toThrow("Cannot add kg and lbs");
   });

   test("throws for different scales", () => {
      const a = of(10, "kg", 12);
      const b = of(5, "kg", 6);

      expect(() => add(a, b)).toThrow(UnitMismatchError);
   });

   test("handles negative values", () => {
      const a = of(10, "kg");
      const b = of(-3, "kg");
      const result = add(a, b);

      expect(result.value).toBe(7_000_000_000_000n);
   });
});

describe("subtract - edge cases", () => {
   test("throws UnitMismatchError for different units", () => {
      const kg = of(10, "kg");
      const m = of(5, "m");

      expect(() => subtract(kg, m)).toThrow(UnitMismatchError);
   });

   test("can result in negative value", () => {
      const a = of(5, "kg");
      const b = of(10, "kg");
      const result = subtract(a, b);

      expect(result.value).toBe(-5_000_000_000_000n);
   });
});

describe("multiply - edge cases", () => {
   test("accepts string scalar", () => {
      const measurement = of(10, "kg");
      const result = multiply(measurement, "2.5");

      expect(result.value).toBe(25_000_000_000_000n);
   });

   test("handles decimal scalars", () => {
      const measurement = of(10, "m");
      const result = multiply(measurement, 0.1);

      expect(result.value).toBe(1_000_000_000_000n);
   });

   test("multiply by zero", () => {
      const measurement = of(10, "kg");
      const result = multiply(measurement, 0);

      expect(result.value).toBe(0n);
   });
});

describe("divide - edge cases", () => {
   test("accepts string scalar", () => {
      const measurement = of(10, "kg");
      const result = divide(measurement, "2");

      expect(result.value).toBe(5_000_000_000_000n);
   });

   test("handles decimal divisors", () => {
      const measurement = of(10, "m");
      const result = divide(measurement, 0.5);

      expect(result.value).toBe(20_000_000_000_000n);
   });

   test("throws on division by zero", () => {
      const measurement = of(10, "kg");

      expect(() => divide(measurement, 0)).toThrow();
   });
});
```

**Step 7: Run full test suite**

Run: `cd libraries/uom && bun test`
Expected: All tests PASS (~95+ tests)

**Step 8: Commit**

```bash
git add libraries/uom/src/operations/arithmetic.ts libraries/uom/__tests__/arithmetic.test.ts libraries/uom/src/index.ts
git commit -m "feat(uom): add arithmetic operations (add, subtract, multiply, divide)

Add core arithmetic operations for measurements:
- add/subtract: combine measurements with same unit
- multiply/divide: scale measurements by numeric values

All operations maintain unit and scale information.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 3: Add Measurement Comparison Operations

**Files:**
- Create: `libraries/uom/src/operations/compare.ts`
- Modify: `libraries/uom/src/index.ts`
- Create: `libraries/uom/__tests__/compare.test.ts`

**Step 1: Write failing tests for comparison operations**

Create `libraries/uom/__tests__/compare.test.ts`:
```typescript
import { describe, expect, test } from "bun:test";
import { equals, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, of } from "../src/index";

describe("equals", () => {
   test("returns true for equal measurements", () => {
      const a = of(10, "kg");
      const b = of(10, "kg");

      expect(equals(a, b)).toBe(true);
   });

   test("returns false for unequal measurements", () => {
      const a = of(10, "kg");
      const b = of(5, "kg");

      expect(equals(a, b)).toBe(false);
   });
});

describe("greaterThan", () => {
   test("returns true when first is greater", () => {
      const a = of(10, "kg");
      const b = of(5, "kg");

      expect(greaterThan(a, b)).toBe(true);
   });
});

describe("lessThan", () => {
   test("returns true when first is less", () => {
      const a = of(5, "kg");
      const b = of(10, "kg");

      expect(lessThan(a, b)).toBe(true);
   });
});
```

**Step 2: Run test to verify it fails**

Run: `cd libraries/uom && bun test __tests__/compare.test.ts`
Expected: FAIL with "equals is not defined"

**Step 3: Implement comparison operations**

Create `libraries/uom/src/operations/compare.ts`:
```typescript
import {
   equals as bigintEquals,
   greaterThan as bigintGreaterThan,
   greaterThanOrEqual as bigintGreaterThanOrEqual,
   lessThan as bigintLessThan,
   lessThanOrEqual as bigintLessThanOrEqual,
} from "@f-o-t/bigint";
import { UnitMismatchError } from "../errors";
import type { Measurement } from "../types/measurement";

/**
 * Check if two measurements are equal
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns true if measurements are equal
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * equals(of(10, "kg"), of(10, "kg")); // true
 * equals(of(10, "kg"), of(5, "kg")); // false
 * ```
 */
export function equals(a: Measurement, b: Measurement): boolean {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot compare ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot compare measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   return bigintEquals({ a: a.value, b: b.value, scale: a.scale });
}

/**
 * Check if first measurement is greater than second
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns true if a > b
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * greaterThan(of(10, "kg"), of(5, "kg")); // true
 * ```
 */
export function greaterThan(a: Measurement, b: Measurement): boolean {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot compare ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot compare measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   return bigintGreaterThan({ a: a.value, b: b.value, scale: a.scale });
}

/**
 * Check if first measurement is greater than or equal to second
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns true if a >= b
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * greaterThanOrEqual(of(10, "kg"), of(10, "kg")); // true
 * ```
 */
export function greaterThanOrEqual(a: Measurement, b: Measurement): boolean {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot compare ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot compare measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   return bigintGreaterThanOrEqual({ a: a.value, b: b.value, scale: a.scale });
}

/**
 * Check if first measurement is less than second
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns true if a < b
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * lessThan(of(5, "kg"), of(10, "kg")); // true
 * ```
 */
export function lessThan(a: Measurement, b: Measurement): boolean {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot compare ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot compare measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   return bigintLessThan({ a: a.value, b: b.value, scale: a.scale });
}

/**
 * Check if first measurement is less than or equal to second
 *
 * @param a - First measurement
 * @param b - Second measurement
 * @returns true if a <= b
 * @throws {UnitMismatchError} If units don't match
 *
 * @example
 * ```typescript
 * lessThanOrEqual(of(5, "kg"), of(5, "kg")); // true
 * ```
 */
export function lessThanOrEqual(a: Measurement, b: Measurement): boolean {
   if (a.unit !== b.unit) {
      throw new UnitMismatchError(
         `Cannot compare ${a.unit} and ${b.unit}. Use convert() first.`,
      );
   }

   if (a.scale !== b.scale) {
      throw new UnitMismatchError(
         `Cannot compare measurements with different scales (${a.scale} vs ${b.scale})`,
      );
   }

   return bigintLessThanOrEqual({ a: a.value, b: b.value, scale: a.scale });
}
```

**Step 4: Export comparison operations**

Modify `libraries/uom/src/index.ts` - add to operations exports:
```typescript
export { equals, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual } from "./operations/compare";
```

**Step 5: Run test to verify basic comparisons pass**

Run: `cd libraries/uom && bun test __tests__/compare.test.ts`
Expected: 3 tests PASS

**Step 6: Add comprehensive comparison tests**

Add to `libraries/uom/__tests__/compare.test.ts`:
```typescript
describe("greaterThanOrEqual", () => {
   test("returns true when first is greater", () => {
      expect(greaterThanOrEqual(of(10, "kg"), of(5, "kg"))).toBe(true);
   });

   test("returns true when equal", () => {
      expect(greaterThanOrEqual(of(10, "kg"), of(10, "kg"))).toBe(true);
   });

   test("returns false when first is less", () => {
      expect(greaterThanOrEqual(of(5, "kg"), of(10, "kg"))).toBe(false);
   });
});

describe("lessThanOrEqual", () => {
   test("returns true when first is less", () => {
      expect(lessThanOrEqual(of(5, "kg"), of(10, "kg"))).toBe(true);
   });

   test("returns true when equal", () => {
      expect(lessThanOrEqual(of(10, "kg"), of(10, "kg"))).toBe(true);
   });

   test("returns false when first is greater", () => {
      expect(lessThanOrEqual(of(10, "kg"), of(5, "kg"))).toBe(false);
   });
});

describe("comparison edge cases", () => {
   test("throws UnitMismatchError for different units", () => {
      const kg = of(10, "kg");
      const m = of(10, "m");

      expect(() => equals(kg, m)).toThrow(UnitMismatchError);
      expect(() => greaterThan(kg, m)).toThrow(UnitMismatchError);
      expect(() => lessThan(kg, m)).toThrow(UnitMismatchError);
   });

   test("throws for different scales", () => {
      const a = of(10, "kg", 12);
      const b = of(10, "kg", 6);

      expect(() => equals(a, b)).toThrow(UnitMismatchError);
   });

   test("handles negative values", () => {
      expect(greaterThan(of(5, "kg"), of(-5, "kg"))).toBe(true);
      expect(lessThan(of(-10, "kg"), of(-5, "kg"))).toBe(true);
      expect(equals(of(-10, "kg"), of(-10, "kg"))).toBe(true);
   });

   test("handles zero", () => {
      expect(equals(of(0, "kg"), of(0, "kg"))).toBe(true);
      expect(greaterThan(of(0, "kg"), of(-1, "kg"))).toBe(true);
      expect(lessThan(of(0, "kg"), of(1, "kg"))).toBe(true);
   });
});
```

**Step 7: Run full test suite**

Run: `cd libraries/uom && bun test`
Expected: All tests PASS (~110+ tests)

**Step 8: Commit**

```bash
git add libraries/uom/src/operations/compare.ts libraries/uom/__tests__/compare.test.ts libraries/uom/src/index.ts
git commit -m "feat(uom): add comparison operations

Add measurement comparison functions:
- equals, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual

All comparisons enforce same-unit requirement.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 4: Add Format Operation

**Files:**
- Create: `libraries/uom/src/operations/format.ts`
- Modify: `libraries/uom/src/index.ts`
- Create: `libraries/uom/__tests__/format.test.ts`

**Step 1: Write failing tests for format operation**

Create `libraries/uom/__tests__/format.test.ts`:
```typescript
import { describe, expect, test } from "bun:test";
import { format, of } from "../src/index";

describe("format", () => {
   test("formats measurement with default options", () => {
      const measurement = of(10.5, "kg");
      expect(format(measurement)).toBe("10.5 kg");
   });

   test("formats with trimmed trailing zeros", () => {
      const measurement = of(10, "kg");
      expect(format(measurement)).toBe("10 kg");
   });
});
```

**Step 2: Run test to verify it fails**

Run: `cd libraries/uom && bun test __tests__/format.test.ts`
Expected: FAIL with "format is not defined"

**Step 3: Implement format operation**

Create `libraries/uom/src/operations/format.ts`:
```typescript
import { formatBigIntToDecimal } from "../utils/precision";
import type { Measurement } from "../types/measurement";

export interface FormatOptions {
   /**
    * Whether to include the unit symbol in output
    * @default true
    */
   includeUnit?: boolean;

   /**
    * Custom unit label (overrides the unit symbol)
    */
   unitLabel?: string;
}

/**
 * Format a measurement as a human-readable string
 *
 * @param measurement - The measurement to format
 * @param options - Formatting options
 * @returns Formatted string representation
 *
 * @example
 * ```typescript
 * format(of(10.5, "kg")); // "10.5 kg"
 * format(of(10.5, "kg"), { includeUnit: false }); // "10.5"
 * format(of(10.5, "kg"), { unitLabel: "kilograms" }); // "10.5 kilograms"
 * ```
 */
export function format(
   measurement: Measurement,
   options: FormatOptions = {},
): string {
   const { includeUnit = true, unitLabel } = options;

   const numericValue = formatBigIntToDecimal(
      measurement.value,
      measurement.scale,
   );

   if (!includeUnit) {
      return numericValue;
   }

   const unit = unitLabel ?? measurement.unit;
   return `${numericValue} ${unit}`;
}
```

**Step 4: Export format operation**

Modify `libraries/uom/src/index.ts` - add to operations exports:
```typescript
export { format, type FormatOptions } from "./operations/format";
```

**Step 5: Run test to verify basic format passes**

Run: `cd libraries/uom && bun test __tests__/format.test.ts`
Expected: 2 tests PASS

**Step 6: Add comprehensive format tests**

Add to `libraries/uom/__tests__/format.test.ts`:
```typescript
test("formats without unit when includeUnit is false", () => {
   const measurement = of(10.5, "kg");
   expect(format(measurement, { includeUnit: false })).toBe("10.5");
});

test("formats with custom unit label", () => {
   const measurement = of(10.5, "kg");
   expect(format(measurement, { unitLabel: "kilograms" })).toBe("10.5 kilograms");
});

test("formats negative values", () => {
   const measurement = of(-5.25, "m");
   expect(format(measurement)).toBe("-5.25 m");
});

test("formats zero", () => {
   const measurement = of(0, "L");
   expect(format(measurement)).toBe("0 L");
});

test("formats very precise values", () => {
   const measurement = of("123.456789012345", "m");
   expect(format(measurement)).toBe("123.456789012345 m");
});

test("formats volume units", () => {
   expect(format(of(2.5, "L"))).toBe("2.5 L");
   expect(format(of(500, "mL"))).toBe("500 mL");
});

test("formats temperature units", () => {
   expect(format(of(100, "°C"))).toBe("100 °C");
   expect(format(of(32, "°F"))).toBe("32 °F");
});
```

**Step 7: Run full test suite**

Run: `cd libraries/uom && bun test`
Expected: All tests PASS (~120+ tests)

**Step 8: Commit**

```bash
git add libraries/uom/src/operations/format.ts libraries/uom/__tests__/format.test.ts libraries/uom/src/index.ts
git commit -m "feat(uom): add format() operation for human-readable output

Add format function to convert measurements to strings:
- Default: includes unit symbol (e.g., \"10.5 kg\")
- Options: custom unit labels, exclude unit

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 5: Add Condition-Evaluator Operators Plugin

**Files:**
- Create: `libraries/uom/src/plugins/operators/index.ts`
- Create: `libraries/uom/src/plugins/operators/comparison.ts`
- Modify: `libraries/uom/fot.config.ts`
- Modify: `libraries/uom/package.json`
- Create: `libraries/uom/__tests__/operators-comparison.test.ts`

**Step 1: Write failing tests for comparison operators**

Create `libraries/uom/__tests__/operators-comparison.test.ts`:
```typescript
import { describe, expect, test } from "bun:test";
import { of } from "../src/index";
import {
   measurementEqualsOperator,
   measurementGreaterThanOperator,
   measurementLessThanOperator,
} from "../src/plugins/operators";

describe("measurementEqualsOperator", () => {
   test("evaluates true for equal measurements", () => {
      const a = of(10, "kg");
      const b = of(10, "kg");

      expect(measurementEqualsOperator.evaluate(a, b)).toBe(true);
   });

   test("evaluates false for unequal measurements", () => {
      const a = of(10, "kg");
      const b = of(5, "kg");

      expect(measurementEqualsOperator.evaluate(a, b)).toBe(false);
   });
});
```

**Step 2: Run test to verify it fails**

Run: `cd libraries/uom && bun test __tests__/operators-comparison.test.ts`
Expected: FAIL with "measurementEqualsOperator is not defined"

**Step 3: Implement comparison operators**

Create `libraries/uom/src/plugins/operators/comparison.ts`:
```typescript
import { createOperator } from "@f-o-t/condition-evaluator";
import { MeasurementSchema } from "../../schemas";
import { equals, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual } from "../../operations/compare";

/**
 * Operator: measurement_eq
 * Check if two measurements are equal
 */
export const measurementEqualsOperator = createOperator({
   name: "measurement_eq",
   type: "custom",
   description: "Check if two measurements are equal (same value and unit)",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return equals(a, b);
   },
   valueSchema: MeasurementSchema,
});

/**
 * Operator: measurement_neq
 * Check if two measurements are not equal
 */
export const measurementNotEqualsOperator = createOperator({
   name: "measurement_neq",
   type: "custom",
   description: "Check if two measurements are not equal",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return !equals(a, b);
   },
   valueSchema: MeasurementSchema,
});

/**
 * Operator: measurement_gt
 * Check if first measurement is greater than second
 */
export const measurementGreaterThanOperator = createOperator({
   name: "measurement_gt",
   type: "custom",
   description: "Check if first measurement is greater than second",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return greaterThan(a, b);
   },
   valueSchema: MeasurementSchema,
});

/**
 * Operator: measurement_gte
 * Check if first measurement is greater than or equal to second
 */
export const measurementGreaterThanOrEqualOperator = createOperator({
   name: "measurement_gte",
   type: "custom",
   description: "Check if first measurement is greater than or equal to second",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return greaterThanOrEqual(a, b);
   },
   valueSchema: MeasurementSchema,
});

/**
 * Operator: measurement_lt
 * Check if first measurement is less than second
 */
export const measurementLessThanOperator = createOperator({
   name: "measurement_lt",
   type: "custom",
   description: "Check if first measurement is less than second",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return lessThan(a, b);
   },
   valueSchema: MeasurementSchema,
});

/**
 * Operator: measurement_lte
 * Check if first measurement is less than or equal to second
 */
export const measurementLessThanOrEqualOperator = createOperator({
   name: "measurement_lte",
   type: "custom",
   description: "Check if first measurement is less than or equal to second",
   evaluate: (actual: unknown, expected: unknown): boolean => {
      const a = MeasurementSchema.parse(actual);
      const b = MeasurementSchema.parse(expected);
      return lessThanOrEqual(a, b);
   },
   valueSchema: MeasurementSchema,
});
```

**Step 4: Create operators index**

Create `libraries/uom/src/plugins/operators/index.ts`:
```typescript
export {
   measurementEqualsOperator,
   measurementGreaterThanOperator,
   measurementGreaterThanOrEqualOperator,
   measurementLessThanOperator,
   measurementLessThanOrEqualOperator,
   measurementNotEqualsOperator,
} from "./comparison";
```

**Step 5: Update fot.config.ts to add operators plugin**

Modify `libraries/uom/fot.config.ts`:
```typescript
import { defineFotConfig } from "@f-o-t/config";

export default defineFotConfig({
   external: ["zod", "@f-o-t/bigint"],
   plugins: ["operators"],
});
```

**Step 6: Update package.json exports and dependencies**

Modify `libraries/uom/package.json`:

Add to exports:
```json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./operators": "./dist/plugins/operators/index.js"
  }
}
```

Add peerDependencies:
```json
{
  "peerDependencies": {
    "@f-o-t/condition-evaluator": "^0.1.0"
  },
  "peerDependenciesMeta": {
    "@f-o-t/condition-evaluator": {
      "optional": true
    }
  }
}
```

Add to devDependencies:
```json
{
  "devDependencies": {
    "@f-o-t/cli": "workspace:*",
    "@f-o-t/config": "workspace:*",
    "@f-o-t/condition-evaluator": "^0.1.0"
  }
}
```

**Step 7: Install dependencies**

Run: `cd /home/yorizel/Documents/fot-libraries && bun install`
Expected: Dependencies installed successfully

**Step 8: Add comprehensive operator tests**

Add to `libraries/uom/__tests__/operators-comparison.test.ts`:
```typescript
describe("measurementNotEqualsOperator", () => {
   test("evaluates true for unequal measurements", () => {
      expect(measurementNotEqualsOperator.evaluate(of(10, "kg"), of(5, "kg"))).toBe(true);
   });

   test("evaluates false for equal measurements", () => {
      expect(measurementNotEqualsOperator.evaluate(of(10, "kg"), of(10, "kg"))).toBe(false);
   });
});

describe("measurementGreaterThanOperator", () => {
   test("evaluates true when first is greater", () => {
      expect(measurementGreaterThanOperator.evaluate(of(10, "kg"), of(5, "kg"))).toBe(true);
   });

   test("evaluates false when first is less or equal", () => {
      expect(measurementGreaterThanOperator.evaluate(of(5, "kg"), of(10, "kg"))).toBe(false);
      expect(measurementGreaterThanOperator.evaluate(of(10, "kg"), of(10, "kg"))).toBe(false);
   });
});

describe("measurementGreaterThanOrEqualOperator", () => {
   test("evaluates true when first is greater or equal", () => {
      expect(measurementGreaterThanOrEqualOperator.evaluate(of(10, "kg"), of(5, "kg"))).toBe(true);
      expect(measurementGreaterThanOrEqualOperator.evaluate(of(10, "kg"), of(10, "kg"))).toBe(true);
   });
});

describe("measurementLessThanOperator", () => {
   test("evaluates true when first is less", () => {
      expect(measurementLessThanOperator.evaluate(of(5, "kg"), of(10, "kg"))).toBe(true);
   });
});

describe("measurementLessThanOrEqualOperator", () => {
   test("evaluates true when first is less or equal", () => {
      expect(measurementLessThanOrEqualOperator.evaluate(of(5, "kg"), of(10, "kg"))).toBe(true);
      expect(measurementLessThanOrEqualOperator.evaluate(of(10, "kg"), of(10, "kg"))).toBe(true);
   });
});

describe("operator metadata", () => {
   test("all operators have correct names", () => {
      expect(measurementEqualsOperator.name).toBe("measurement_eq");
      expect(measurementNotEqualsOperator.name).toBe("measurement_neq");
      expect(measurementGreaterThanOperator.name).toBe("measurement_gt");
      expect(measurementGreaterThanOrEqualOperator.name).toBe("measurement_gte");
      expect(measurementLessThanOperator.name).toBe("measurement_lt");
      expect(measurementLessThanOrEqualOperator.name).toBe("measurement_lte");
   });
});
```

**Step 9: Run test to verify operators pass**

Run: `cd libraries/uom && bun test __tests__/operators-comparison.test.ts`
Expected: All tests PASS

**Step 10: Build library to verify plugin export**

Run: `cd libraries/uom && bun run build`
Expected: Build succeeds, dist/plugins/operators/index.js created

**Step 11: Commit**

```bash
git add libraries/uom/src/plugins libraries/uom/__tests__/operators-comparison.test.ts libraries/uom/fot.config.ts libraries/uom/package.json bun.lock
git commit -m "feat(uom): add condition-evaluator operators plugin

Add 6 comparison operators for condition-evaluator integration:
- measurement_eq, measurement_neq
- measurement_gt, measurement_gte
- measurement_lt, measurement_lte

Available at @f-o-t/uom/operators

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 6: Write Comprehensive README Documentation

**Files:**
- Modify: `libraries/uom/README.md`

**Step 1: Backup current README**

Run: `cp libraries/uom/README.md libraries/uom/README.md.bak`
Expected: Backup created

**Step 2: Write comprehensive README**

Replace `libraries/uom/README.md` with:
```markdown
# @f-o-t/uom

Type-safe units of measurement library with BigInt precision for JavaScript and TypeScript.

## Features

- **Precision-First**: Uses BigInt internally for exact conversions without floating-point errors
- **Type Safety**: Full TypeScript support with Zod validation
- **Comprehensive Units**: Weight, volume, length, area, temperature with extensible registry
- **Rich Operations**: Convert, add, subtract, multiply, divide, compare measurements
- **Condition-Evaluator Integration**: Optional operators plugin for business rules
- **Immutable API**: All operations return new instances
- **Zero Dependencies**: Only requires @f-o-t/bigint and Zod

## Installation

```bash
bun add @f-o-t/uom
# or
npm install @f-o-t/uom
# or
pnpm add @f-o-t/uom
```

## Quick Start

```typescript
import { of, convert, add, format } from "@f-o-t/uom";

// Create measurements
const weight = of(10.5, "kg");
const height = of(1.75, "m");

// Convert units
const inPounds = convert(weight, "lbs"); // 23.1485 lbs

// Arithmetic operations
const total = add(of(10, "kg"), of(5, "kg")); // 15 kg
const doubled = multiply(weight, 2); // 21 kg

// Comparisons
if (greaterThan(weight, of(5, "kg"))) {
  console.log("Heavy!");
}

// Format for display
console.log(format(weight)); // "10.5 kg"
```

## Core Concepts

### Measurements

A measurement combines a numeric value, unit, scale (decimal precision), and category:

```typescript
interface Measurement {
  value: bigint;      // Internal BigInt for precision
  unit: UnitSymbol;   // e.g., "kg", "m", "L"
  scale: number;      // Decimal places (default: 12)
  category: Category; // "weight", "length", "volume", etc.
}
```

### Factory Functions

Create measurements with `of()` or `zero()`:

```typescript
import { of, zero } from "@f-o-t/uom";

// From number or string
const mass = of(10.5, "kg");
const length = of("2.5", "m");
const volume = of(500, "mL");

// With custom scale (precision)
const precise = of(123.456789012345, "m", 12); // 12 decimal places

// Zero value
const empty = zero("L");
```

## Operations

### Unit Conversion

Convert measurements between compatible units (same category):

```typescript
import { convert, of } from "@f-o-t/uom";

const kg = of(10, "kg");
const lbs = convert(kg, "lbs"); // 22.046226218 lbs

const meters = of(1000, "m");
const km = convert(meters, "km"); // 1 km

const celsius = of(100, "°C");
const fahrenheit = convert(celsius, "°F"); // 212°F
```

**Note:** Throws `ConversionError` if units are from different categories (e.g., weight to length).

### Arithmetic Operations

#### Addition & Subtraction

Combine measurements with the **same unit**:

```typescript
import { add, subtract, of } from "@f-o-t/uom";

const total = add(of(10, "kg"), of(5, "kg")); // 15 kg
const remaining = subtract(of(10, "kg"), of(3, "kg")); // 7 kg

// Different units? Convert first!
const kg = of(10, "kg");
const lbs = of(5, "lbs");
const kgFromLbs = convert(lbs, "kg");
const combined = add(kg, kgFromLbs); // ~12.26796 kg
```

**Note:** Throws `UnitMismatchError` if units don't match.

#### Multiplication & Division

Scale measurements by numeric values:

```typescript
import { multiply, divide, of } from "@f-o-t/uom";

const doubled = multiply(of(10, "kg"), 2); // 20 kg
const tripled = multiply(of(5, "m"), "3.5"); // 17.5 m

const half = divide(of(10, "kg"), 2); // 5 kg
const third = divide(of(9, "L"), 3); // 3 L
```

### Comparison Operations

Compare measurements with the **same unit**:

```typescript
import { equals, greaterThan, lessThan, of } from "@f-o-t/uom";

const a = of(10, "kg");
const b = of(5, "kg");

equals(a, b); // false
greaterThan(a, b); // true
greaterThanOrEqual(a, of(10, "kg")); // true
lessThan(b, a); // true
lessThanOrEqual(b, a); // true
```

**Available comparisons:**
- `equals(a, b)` - Equal
- `greaterThan(a, b)` - Greater than
- `greaterThanOrEqual(a, b)` - Greater than or equal
- `lessThan(a, b)` - Less than
- `lessThanOrEqual(a, b)` - Less than or equal

**Note:** Throws `UnitMismatchError` if units don't match. Convert first if needed.

### Formatting

Convert measurements to human-readable strings:

```typescript
import { format, of } from "@f-o-t/uom";

const weight = of(10.5, "kg");

// Default: includes unit
format(weight); // "10.5 kg"

// Custom options
format(weight, { includeUnit: false }); // "10.5"
format(weight, { unitLabel: "kilograms" }); // "10.5 kilograms"

// Trailing zeros are trimmed
format(of(10, "kg")); // "10 kg" (not "10.000000000000")
```

## Built-in Units

### Weight
- **Metric**: `kg` (kilogram), `g` (gram), `mg` (milligram)
- **Imperial**: `lbs` (pound), `oz` (ounce)

### Length
- **Metric**: `km` (kilometer), `m` (meter), `cm` (centimeter), `mm` (millimeter)
- **Imperial**: `mi` (mile), `yd` (yard), `ft` (foot), `in` (inch)

### Volume
- **Metric**: `L` (liter), `mL` (milliliter)
- **Imperial**: `gal` (gallon), `qt` (quart), `pt` (pint), `cup`, `fl oz` (fluid ounce), `tbsp` (tablespoon), `tsp` (teaspoon)

### Area
- **Metric**: `km²` (square kilometer), `m²` (square meter), `cm²` (square centimeter)
- **Imperial**: `mi²` (square mile), `yd²` (square yard), `ft²` (square foot), `in²` (square inch)

### Temperature
- `°C` (Celsius), `°F` (Fahrenheit), `K` (Kelvin)

## Custom Units

Register your own units at runtime:

```typescript
import { registerUnit, of, convert } from "@f-o-t/uom";

// Register a custom unit
registerUnit({
  symbol: "stone",
  name: "Stone",
  category: "weight",
  toBaseMultiplier: 6350293180000n, // 1 stone = 6.35029318 kg (at scale 12)
});

// Use it immediately
const weight = of(10, "stone");
const kg = convert(weight, "kg"); // 63.5029318 kg
```

### Unit Registry API

```typescript
import { getUnit, getAllUnits, getUnitsByCategory, hasUnit, clearCustomUnits } from "@f-o-t/uom";

// Get unit definition
const kgDef = getUnit("kg");
// { symbol: "kg", name: "Kilogram", category: "weight", ... }

// Get all units in a category
const weightUnits = getUnitsByCategory("weight");
// [{ symbol: "kg", ... }, { symbol: "lbs", ... }, ...]

// Get all registered units
const allUnits = getAllUnits();

// Check if unit exists
if (hasUnit("kg")) {
  // ...
}

// Clear custom units (built-ins remain)
clearCustomUnits();
```

## Condition-Evaluator Integration

Optional operators plugin for business rules and conditional logic:

### Installation

```bash
bun add @f-o-t/condition-evaluator
```

### Usage

```typescript
import { evaluateCondition } from "@f-o-t/condition-evaluator";
import { of } from "@f-o-t/uom";
import {
  measurementEqualsOperator,
  measurementGreaterThanOperator,
  measurementLessThanOperator,
} from "@f-o-t/uom/operators";

// Register operators
const evaluate = evaluateCondition({
  operators: [
    measurementEqualsOperator,
    measurementGreaterThanOperator,
    measurementLessThanOperator,
  ],
});

// Use in conditions
const weight = of(10, "kg");

evaluate({
  actual: weight,
  operator: "measurement_gt",
  expected: of(5, "kg"),
}); // true

evaluate({
  actual: weight,
  operator: "measurement_eq",
  expected: of(10, "kg"),
}); // true
```

### Available Operators

| Operator | Description |
|----------|-------------|
| `measurement_eq` | Equal to |
| `measurement_neq` | Not equal to |
| `measurement_gt` | Greater than |
| `measurement_gte` | Greater than or equal |
| `measurement_lt` | Less than |
| `measurement_lte` | Less than or equal |

All operators validate inputs and enforce same-unit requirements.

## Type Definitions

### Measurement Input

For JSON serialization and parsing:

```typescript
import { type MeasurementInput } from "@f-o-t/uom";

const input: MeasurementInput = {
  value: "10.5",
  unit: "kg",
  scale: 12,
};
```

### Unit Definition

For custom unit registration:

```typescript
import { type UnitDefinition } from "@f-o-t/uom";

const customUnit: UnitDefinition = {
  symbol: "stone",
  name: "Stone",
  category: "weight",
  toBaseMultiplier: 6350293180000n,
};
```

## Error Handling

All operations throw typed errors:

```typescript
import {
  ConversionError,
  UnitMismatchError,
  CategoryMismatchError,
  UnknownUnitError,
  InvalidMeasurementError,
} from "@f-o-t/uom";

try {
  const kg = of(10, "kg");
  const m = of(5, "m");
  add(kg, m); // Throws UnitMismatchError
} catch (error) {
  if (error instanceof UnitMismatchError) {
    console.error("Cannot add different units");
  }
}
```

**Error Types:**
- `ConversionError` - Invalid unit conversion (different categories)
- `UnitMismatchError` - Operations on incompatible units
- `CategoryMismatchError` - Category validation failures
- `UnknownUnitError` - Unknown unit symbol
- `InvalidMeasurementError` - Invalid measurement data

## Advanced: Scale & Precision

The `scale` parameter controls decimal precision (default: 12):

```typescript
import { of, DEFAULT_SCALE } from "@f-o-t/uom";

console.log(DEFAULT_SCALE); // 12

// Default scale (12 decimal places)
const standard = of(10.123456789012, "kg");

// Custom scale
const highPrecision = of(10.123456789012, "kg", 15); // 15 decimals
const lowPrecision = of(10.123456789012, "kg", 6);   // 6 decimals
```

**Important:**
- Operations require same scale (arithmetic, comparison)
- Conversions preserve the source scale
- Higher scale = more precision but larger BigInt values

## Best Practices

### 1. Convert Before Combining

```typescript
// ❌ Bad - will throw UnitMismatchError
add(of(10, "kg"), of(5, "lbs"));

// ✅ Good - convert first
const kg = of(10, "kg");
const lbsAsKg = convert(of(5, "lbs"), "kg");
add(kg, lbsAsKg);
```

### 2. Use Consistent Scales

```typescript
// ❌ Bad - different scales will throw
const a = of(10, "kg", 12);
const b = of(5, "kg", 6);
add(a, b); // Error!

// ✅ Good - same scale
const a = of(10, "kg", 12);
const b = of(5, "kg", 12);
add(a, b); // Works
```

### 3. Format for Display Only

```typescript
// ❌ Bad - format is for humans, not computation
const formatted = format(of(10, "kg"));
const parsed = of(formatted.split(" ")[0], "kg"); // Fragile!

// ✅ Good - keep measurements in structured form
const measurement = of(10, "kg");
// ... do calculations ...
const display = format(measurement); // Format at the end
```

### 4. Register Custom Units Once

```typescript
// ✅ Good - register at app startup
function initializeApp() {
  registerUnit({ symbol: "stone", ... });
  registerUnit({ symbol: "furlong", ... });
}

// ❌ Bad - registering in hot paths
function calculateWeight(value: number) {
  registerUnit({ symbol: "stone", ... }); // Inefficient!
  return of(value, "stone");
}
```

## Comparison with Alternatives

| Feature | @f-o-t/uom | js-quantities | mathjs |
|---------|-----------|---------------|--------|
| BigInt Precision | ✅ | ❌ (float) | ❌ (float) |
| Type Safety | ✅ Full TS | Partial | Partial |
| Tree Shakeable | ✅ | ❌ | ❌ |
| Zero Config | ✅ | ✅ | ❌ |
| Custom Units | ✅ Runtime | ❌ | ✅ |
| Bundle Size | ~15KB | ~50KB | ~500KB |

## API Reference

### Factory Functions
- `of(value, unit, scale?)` - Create measurement
- `zero(unit, scale?)` - Create zero-valued measurement

### Operations
- `convert(measurement, targetUnit)` - Convert units
- `add(a, b)` - Add measurements
- `subtract(a, b)` - Subtract measurements
- `multiply(measurement, scalar)` - Multiply by number
- `divide(measurement, scalar)` - Divide by number
- `equals(a, b)` - Check equality
- `greaterThan(a, b)` - Check if first > second
- `greaterThanOrEqual(a, b)` - Check if first >= second
- `lessThan(a, b)` - Check if first < second
- `lessThanOrEqual(a, b)` - Check if first <= second
- `format(measurement, options?)` - Format as string

### Registry
- `registerUnit(definition)` - Register custom unit
- `getUnit(symbol)` - Get unit definition
- `getAllUnits()` - Get all units
- `getUnitsByCategory(category)` - Get category units
- `hasUnit(symbol)` - Check if unit exists
- `clearCustomUnits()` - Clear custom units

## License

MIT © [F-O-T]

## Contributing

Contributions welcome! Please read [CONTRIBUTING.md](../../CONTRIBUTING.md) first.

## Links

- [Changelog](./CHANGELOG.md)
- [GitHub](https://github.com/F-O-T/libraries)
- [Issues](https://github.com/F-O-T/libraries/issues)
```

**Step 3: Remove backup**

Run: `rm libraries/uom/README.md.bak`
Expected: Backup removed

**Step 4: Verify README renders correctly**

Run: `head -50 libraries/uom/README.md`
Expected: Shows formatted markdown

**Step 5: Commit**

```bash
git add libraries/uom/README.md
git commit -m "docs(uom): add comprehensive README for 1.0.0

Complete API documentation including:
- Quick start and installation
- All operations (convert, arithmetic, comparison, format)
- Built-in units reference
- Custom unit registration
- Condition-evaluator integration guide
- Type definitions and error handling
- Best practices and examples

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 7: Update CHANGELOG for 1.0.0 Release

**Files:**
- Modify: `libraries/uom/CHANGELOG.md`
- Modify: `libraries/uom/package.json`

**Step 1: Add 1.0.0 entry to CHANGELOG**

Prepend to `libraries/uom/CHANGELOG.md` (after header, before 0.2.0):
```markdown
## [1.0.0] - 2026-02-01

### Added

- **Operations**
  - `convert()` - Convert measurements between units in the same category
  - `add()` - Add two measurements with same unit
  - `subtract()` - Subtract measurements with same unit
  - `multiply()` - Multiply measurement by scalar value
  - `divide()` - Divide measurement by scalar value
  - `equals()`, `greaterThan()`, `greaterThanOrEqual()`, `lessThan()`, `lessThanOrEqual()` - Comparison operations
  - `format()` - Format measurements as human-readable strings with options

- **Condition-Evaluator Integration**
  - 6 comparison operators for business rules: `measurement_eq`, `measurement_neq`, `measurement_gt`, `measurement_gte`, `measurement_lt`, `measurement_lte`
  - Plugin export available at `@f-o-t/uom/operators`
  - Optional peer dependency on `@f-o-t/condition-evaluator`

- **Documentation**
  - Comprehensive README with complete API reference
  - Usage examples for all operations
  - Built-in units reference table
  - Custom unit registration guide
  - Condition-evaluator integration examples
  - Best practices and comparison with alternatives

### Changed

- **Public API Stabilization**: All exports are now considered stable and will follow semantic versioning
- **Breaking Change**: None - this release is fully backward compatible with 0.2.0

### Design Decisions

- All arithmetic operations require same unit (use `convert()` first if needed)
- All comparisons require same unit and scale
- Format function trims trailing zeros by default
- Operations return new Measurement instances (immutable)
- Operators plugin is optional (peer dependency)

[1.0.0]: https://github.com/F-O-T/libraries/releases/tag/@f-o-t/uom@1.0.0
```

**Step 2: Update version in package.json**

Modify `libraries/uom/package.json`:
```json
{
  "version": "1.0.0"
}
```

**Step 3: Run final test suite**

Run: `cd libraries/uom && bun test`
Expected: All tests PASS (~120+ tests)

**Step 4: Run type checking**

Run: `cd libraries/uom && bun run typecheck`
Expected: No type errors

**Step 5: Build library**

Run: `cd libraries/uom && bun run build`
Expected: Build succeeds, both main and operators entries built

**Step 6: Commit**

```bash
git add libraries/uom/CHANGELOG.md libraries/uom/package.json
git commit -m "chore(uom): release version 1.0.0

Stable release with complete measurement operations API:
- Unit conversion, arithmetic, comparisons, formatting
- Condition-evaluator operators plugin
- Comprehensive documentation
- API stability commitment

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Post-Release Checklist

After completing all tasks, verify:

- [ ] All tests pass (~120+ tests)
- [ ] No type errors
- [ ] Build succeeds for both entry points (main + operators)
- [ ] README is comprehensive and accurate
- [ ] CHANGELOG documents all changes
- [ ] Version is 1.0.0
- [ ] All operations are exported
- [ ] Operators plugin is available at @f-o-t/uom/operators
- [ ] Package.json has correct exports and peer dependencies

## Rollback Plan

If critical issues are found:

1. **Revert to 0.2.0**
   ```bash
   git revert <1.0.0-release-commit>..HEAD
   cd libraries/uom && bun install && bun test
   ```

2. **Fix issues**
   - Document the problem
   - Create fix PR
   - Test thoroughly

3. **Re-release as 1.0.1**
   - Apply fixes
   - Update CHANGELOG
   - Release patch version

## Notes

- **Semver Commitment**: After 1.0.0, all changes must follow semantic versioning
- **Breaking Changes**: Require major version bump (2.0.0)
- **New Features**: Require minor version bump (1.1.0)
- **Bug Fixes**: Require patch version bump (1.0.1)
- **Operators Plugin**: Optional integration - not required for core functionality
- **Tests**: Each new operation should have 10+ tests covering edge cases
- **Documentation**: Every exported function must have JSDoc and README entry
