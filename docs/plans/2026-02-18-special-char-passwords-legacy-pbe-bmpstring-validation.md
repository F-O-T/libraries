# Special-Char Passwords, Legacy PBE Coverage & BMPString Validation

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix silent BMPString corruption for supplementary Unicode characters, add test coverage for the legacy PBE-SHA1-3DES decryption path, and verify special-character passwords work end-to-end.

**Architecture:**
- `libraries/crypto/src/pkcs12.ts` contains `passwordToBmpString` (line 280). Add a guard loop that throws `Pkcs12Error` when a JS string contains UTF-16 surrogate code units (i.e. chars > U+FFFF).
- Two new test fixtures generated via OpenSSL in `beforeAll`: one using PBE-SHA1-3DES (covers `decryptShroudedKeyBag â†’ decryptPbe â†’ pkcs12Kdf` path) and one using a special-character password with the modern PBES2 format.
- The digital-certificate library needs a matching special-char fixture to test `parseCertificate` end-to-end.

**Tech Stack:** Bun test runner, OpenSSL CLI (available at `/usr/bin/openssl`), `node:child_process.execSync`, TypeScript.

---

## Task 1: Write failing test for emoji password throwing `Pkcs12Error`

**Files:**
- Modify: `libraries/crypto/__tests__/pkcs12.test.ts`

**Step 1: Add the failing test to the existing describe block**

Add this test inside `describe("parsePkcs12", ...)` after the existing `"throws on corrupted data"` test:

```typescript
it("throws Pkcs12Error with clear message when password contains supplementary Unicode chars (emoji)", async () => {
  const p12Data = new Uint8Array(await Bun.file(p12Path).arrayBuffer());
  expect(() => parsePkcs12(p12Data, "test\u{1F600}123")).toThrow(
    "PKCS#12 BMPString encoding only supports U+0000",
  );
});
```

Note: `\u{1F600}` is ðŸ˜€ (U+1F600), a supplementary character encoded as two UTF-16 surrogates in JS.

**Step 2: Run the test to verify it fails**

```bash
cd /home/yorizel/Documents/fot-libraries
bun x --bun fot test 2>&1 | grep -A5 "emoji"
```

Expected: test runs but **fails** because `parsePkcs12` does not yet throw the BMPString error (it will instead fail with a confusing "MAC verification failed (wrong password?)" error).

---

## Task 2: Add BMPString surrogate validation to `passwordToBmpString`

**Files:**
- Modify: `libraries/crypto/src/pkcs12.ts:280-294`

**Step 3: Add validation loop before the existing logic**

Replace `passwordToBmpString` (lines 280â€“294) with:

```typescript
function passwordToBmpString(password: string): Uint8Array {
   // BMPString only allows U+0000â€“U+FFFF. Supplementary chars (U+10000+) are
   // represented as UTF-16 surrogate pairs in JS. Detect and reject them.
   for (let i = 0; i < password.length; i++) {
      const code = password.charCodeAt(i);
      if (code >= 0xd800 && code <= 0xdfff) {
         throw new Pkcs12Error(
            "Password contains a character outside the Unicode BMP (U+10000+). " +
               "PKCS#12 BMPString encoding only supports U+0000\u2013U+FFFF.",
         );
      }
   }
   // BMP encoding: each character as 2 bytes (UTF-16BE), plus 0x00 0x00 terminator
   if (password.length === 0) {
      // Empty password is encoded as just the null terminator
      return new Uint8Array([0x00, 0x00]);
   }
   const result = new Uint8Array(password.length * 2 + 2);
   for (let i = 0; i < password.length; i++) {
      const code = password.charCodeAt(i);
      result[i * 2] = (code >>> 8) & 0xff;
      result[i * 2 + 1] = code & 0xff;
   }
   // Null terminator already 0x00 0x00 from Uint8Array initialization
   return result;
}
```

**Step 4: Run the test to verify it passes**

```bash
cd /home/yorizel/Documents/fot-libraries
bun x --bun fot test 2>&1 | grep -E "(PASS|FAIL|emoji)"
```

Expected: the emoji test now **passes**; all other tests also pass.

**Step 5: Commit**

```bash
git add libraries/crypto/src/pkcs12.ts libraries/crypto/__tests__/pkcs12.test.ts
git commit -m "fix(crypto): throw Pkcs12Error for supplementary Unicode chars in passwordToBmpString"
```

---

## Task 3: Write failing tests for legacy PBE-SHA1-3DES and special-char password

**Files:**
- Modify: `libraries/crypto/__tests__/pkcs12.test.ts`

**Step 6: Add fixture paths and a second `beforeAll` to generate the new fixtures**

At the top of the file, after the existing `p12Path` declaration, add:

```typescript
const legacyP12Path = join(fixtureDir, "test-legacy-3des.p12");
const specialCharP12Path = join(fixtureDir, "test-special-char.p12");
const specialCharPassword = "SÃªnh@123!";
```

After the existing `beforeAll` block, add:

```typescript
beforeAll(() => {
  // Generate legacy PBE-SHA1-3DES fixture (covers decryptPbe â†’ pkcs12Kdf â†’ 3DES path)
  if (!existsSync(legacyP12Path)) {
    const keyPath = join(fixtureDir, "key.pem");
    const certPath = join(fixtureDir, "cert.pem");
    // Use existing key/cert (generated by first beforeAll)
    // -keypbe and -certpbe force PBE-SHA1-3DES for both key and cert bags
    execSync(
      `openssl pkcs12 -export -keypbe PBE-SHA1-3DES -certpbe PBE-SHA1-3DES ` +
        `-out "${legacyP12Path}" -inkey "${keyPath}" -in "${certPath}" -password pass:test123`,
      { stdio: "pipe" },
    );
  }

  // Generate special-char password fixture (PBES2/AES-256-CBC, password with accented + special chars)
  if (!existsSync(specialCharP12Path)) {
    const keyPath = join(fixtureDir, "key.pem");
    const certPath = join(fixtureDir, "cert.pem");
    execSync(
      `openssl pkcs12 -export -out "${specialCharP12Path}" ` +
        `-inkey "${keyPath}" -in "${certPath}" -password "pass:${specialCharPassword}"`,
      { stdio: "pipe" },
    );
  }
});
```

**Step 7: Add new describe block for legacy PBE and special-char tests**

Append at the end of `libraries/crypto/__tests__/pkcs12.test.ts`:

```typescript
describe("parsePkcs12 â€“ legacy PBE-SHA1-3DES", () => {
  it("extracts certificate from legacy 3DES P12", async () => {
    const p12Data = new Uint8Array(await Bun.file(legacyP12Path).arrayBuffer());
    const result = parsePkcs12(p12Data, "test123");

    expect(result.certificate).toBeInstanceOf(Uint8Array);
    expect(result.certificate.length).toBeGreaterThan(0);
    expect(result.certificate[0]).toBe(0x30);
  });

  it("extracts private key from legacy 3DES P12", async () => {
    const p12Data = new Uint8Array(await Bun.file(legacyP12Path).arrayBuffer());
    const result = parsePkcs12(p12Data, "test123");

    expect(result.privateKey).toBeInstanceOf(Uint8Array);
    expect(result.privateKey.length).toBeGreaterThan(0);
    expect(result.privateKey[0]).toBe(0x30);
  });

  it("throws on wrong password for legacy 3DES P12", async () => {
    const p12Data = new Uint8Array(await Bun.file(legacyP12Path).arrayBuffer());
    expect(() => parsePkcs12(p12Data, "wrongpassword")).toThrow();
  });
});

describe("parsePkcs12 â€“ special-character passwords", () => {
  it("parses P12 with accented and special-char password (SÃªnh@123!)", async () => {
    const p12Data = new Uint8Array(
      await Bun.file(specialCharP12Path).arrayBuffer(),
    );
    const result = parsePkcs12(p12Data, specialCharPassword);

    expect(result.certificate).toBeInstanceOf(Uint8Array);
    expect(result.certificate[0]).toBe(0x30);
    expect(result.privateKey).toBeInstanceOf(Uint8Array);
    expect(result.privateKey[0]).toBe(0x30);
  });

  it("throws on wrong password when correct password has special chars", async () => {
    const p12Data = new Uint8Array(
      await Bun.file(specialCharP12Path).arrayBuffer(),
    );
    expect(() => parsePkcs12(p12Data, "test123")).toThrow();
  });
});
```

**Step 8: Run the tests to verify they fail**

```bash
cd /home/yorizel/Documents/fot-libraries
bun x --bun fot test 2>&1 | grep -E "(PASS|FAIL|3DES|special)"
```

Expected: both new describe blocks **fail** because the fixture files don't exist yet (they'll be created on first run via `beforeAll`, so actually the tests may fail with a parse error if the fixtures need generation). The `beforeAll` will create them and the tests may pass on second run â€” this is acceptable because the `beforeAll` handles generation. Verify by running the test a **second** time to confirm they pass.

Actually: `beforeAll` runs before the tests, so on first run it generates the files and the tests should pass. To confirm TDD, verify the tests **would** fail without the implementation by temporarily commenting out the `beforeAll` fixture generation.

**Step 9: Commit**

```bash
git add libraries/crypto/__tests__/pkcs12.test.ts
git commit -m "test(crypto): add failing tests for legacy PBE-SHA1-3DES path and special-char passwords"
```

---

## Task 4: Run full crypto test suite â€” verify all tests pass

**Step 10: Run tests in the crypto library**

```bash
cd /home/yorizel/Documents/fot-libraries/libraries/crypto
bun x --bun fot test
```

Expected output:
- All 4 original `parsePkcs12` tests pass
- 3 new `parsePkcs12 â€“ legacy PBE-SHA1-3DES` tests pass
- 2 new `parsePkcs12 â€“ special-character passwords` tests pass
- 1 emoji validation test passes
- No errors, no warnings

**Step 11: Commit**

```bash
git add libraries/crypto/__tests__/pkcs12.test.ts libraries/crypto/__tests__/fixtures/
git commit -m "test(crypto): add test coverage for legacy PBE-SHA1-3DES, special-char and emoji passwords"
```

---

## Task 5: Add special-char password test to `digital-certificate`

**Files:**
- Modify: `libraries/digital-certificate/__tests__/certificate.test.ts`

**Step 12: Add fixture path and beforeAll for special-char PFX**

At the top of `certificate.test.ts`, after the existing fixture declarations, add:

```typescript
import { execSync } from "node:child_process";
import { existsSync } from "node:fs";
```

Then add a `beforeAll` that generates a simple PFX with special-char password (note: this is a standalone PFX without Brazilian OIDs, so we only assert on basic fields):

```typescript
const specialCharPfxPath = join(fixturesDir, "test-special-char.pfx");
const specialCharPassword = "SÃªnh@123!";

beforeAll(() => {
  if (!existsSync(specialCharPfxPath)) {
    const keyPath = join(fixturesDir, "key-sc.pem");
    const certPath = join(fixturesDir, "cert-sc.pem");
    execSync(
      `openssl req -x509 -newkey rsa:2048 -keyout "${keyPath}" -out "${certPath}" ` +
        `-days 3650 -nodes -subj "/CN=SpecialTest/O=FOT"`,
      { stdio: "pipe" },
    );
    execSync(
      `openssl pkcs12 -export -out "${specialCharPfxPath}" ` +
        `-inkey "${keyPath}" -in "${certPath}" -password "pass:${specialCharPassword}"`,
      { stdio: "pipe" },
    );
  }
});
```

**Step 13: Add the special-char password test**

Append a new describe block at the end of `certificate.test.ts`:

```typescript
describe("parseCertificate â€“ special-character passwords", () => {
  it("parses PFX with accented and special-char password (SÃªnh@123!)", () => {
    const pfx = readFileSync(specialCharPfxPath);
    const cert = parseCertificate(pfx, specialCharPassword);

    expect(cert.certPem).toContain("-----BEGIN CERTIFICATE-----");
    expect(cert.keyPem).toContain("-----BEGIN PRIVATE KEY-----");
    expect(cert.serialNumber).toBeDefined();
  });

  it("throws on wrong password when correct password has special chars", () => {
    const pfx = readFileSync(specialCharPfxPath);
    expect(() => parseCertificate(pfx, "test1234")).toThrow();
  });

  it("throws Pkcs12Error with clear message for emoji password", () => {
    const pfx = readFileSync(specialCharPfxPath);
    expect(() => parseCertificate(pfx, "test\u{1F600}123")).toThrow(
      "PKCS#12 BMPString encoding only supports U+0000",
    );
  });
});
```

**Step 14: Run tests to verify they fail (before fixture exists)**

```bash
cd /home/yorizel/Documents/fot-libraries/libraries/digital-certificate
bun x --bun fot test
```

The `beforeAll` will generate the fixture, so tests should pass on first run. To confirm TDD: tests should pass after the fixture is generated.

**Step 15: Commit**

```bash
git add libraries/digital-certificate/__tests__/certificate.test.ts
git commit -m "test(digital-certificate): add special-char password and emoji error tests"
```

---

## Task 6: Run full workspace test suite

**Step 16: Run all tests**

```bash
cd /home/yorizel/Documents/fot-libraries
bun run test
```

Expected: all tests pass across all libraries.

**Step 17: Update CHANGELOG files**

`libraries/crypto/CHANGELOG.md` â€” add under `[Unreleased]`:
```
### Fixed
- `passwordToBmpString` now throws `Pkcs12Error` with a clear message when the password contains supplementary Unicode characters (U+10000+, e.g. emoji), instead of silently producing incorrect key material.

### Added
- Test coverage for legacy PBE-SHA1-3DES decryption path (`decryptShroudedKeyBag â†’ decryptPbe â†’ pkcs12Kdf`).
- Test coverage for PKCS#12 parsing with special-character passwords (accented Latin chars, ASCII special chars).
- Test validation that emoji passwords produce a clear `Pkcs12Error`.
```

`libraries/digital-certificate/CHANGELOG.md` â€” add under `[Unreleased]`:
```
### Added
- Test coverage for `parseCertificate` with special-character passwords (accented Latin chars, ASCII special chars).
- Test that emoji passwords produce a clear error from the underlying `Pkcs12Error`.
```

**Step 18: Final commit**

```bash
git add libraries/crypto/CHANGELOG.md libraries/digital-certificate/CHANGELOG.md
git commit -m "docs: update changelogs for BMPString validation and test coverage additions"
```
