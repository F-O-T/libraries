# @f-o-t/security — Input Validation & Security Utilities

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a security utilities library to prevent common vulnerabilities in AI-generated code: path traversal, XSS, SQL injection, command injection. Pure functional API with Zod validation.

**Architecture:** Four modules (path, html, sql, shell) each exporting pure validation/sanitization functions. A `Result<T>` type for safe error handling. All input validated via Zod schemas. Zero external dependencies (except Zod).

**Tech Stack:** TypeScript, Bun, Zod ^4.3.6, @f-o-t/cli, @f-o-t/config

---

## Context

**Why:** AI-generated code (vibe-coded apps) commonly has path traversal, XSS, and injection vulnerabilities that tools like Arcjet don't catch at the code level.

**FOT patterns to follow:** See `@f-o-t/bigint` for reference — pure functions, object parameters, Zod schemas, `__tests__/` directory, `.npmignore`.

**File structure:**
```
libraries/security/
├── src/
│   ├── index.ts
│   ├── types.ts
│   ├── schemas.ts
│   ├── path/
│   │   ├── sanitize.ts
│   │   └── validate.ts
│   ├── html/
│   │   ├── escape.ts
│   │   └── sanitize.ts
│   ├── sql/
│   │   └── escape.ts
│   └── shell/
│       ├── escape.ts
│       └── validate.ts
├── __tests__/
│   ├── path.test.ts
│   ├── html.test.ts
│   ├── sql.test.ts
│   └── shell.test.ts
├── fot.config.ts
├── package.json
├── CHANGELOG.md
├── .npmignore
└── README.md
```

---

## Task 1: Scaffold Library

**Step 1: Create the library directory and config files**

```bash
mkdir -p libraries/security/src/{path,html,sql,shell}
mkdir -p libraries/security/__tests__
```

**Step 2: Write fot.config.ts**

```typescript
// libraries/security/fot.config.ts
import { defineFotConfig } from "@f-o-t/config";

export default defineFotConfig({
  external: ["zod"],
});
```

**Step 3: Write package.json**

```json
{
  "name": "@f-o-t/security",
  "version": "1.0.0",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "bun x --bun fot build",
    "test": "bun x --bun fot test",
    "lint": "bun x --bun fot lint",
    "format": "bun x --bun fot format",
    "check": "bun x --bun fot check"
  },
  "dependencies": {
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@f-o-t/cli": "^1.0.1",
    "@f-o-t/config": "^1.0.3",
    "@types/bun": "latest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/F-O-T/libraries.git",
    "directory": "libraries/security"
  }
}
```

**Step 4: Write .npmignore**

```
src/
__tests__/
*.test.ts
tsconfig.json
fot.config.ts
biome.json
.turbo
```

**Step 5: Commit**

```bash
git add libraries/security/
git commit -m "chore(security): scaffold @f-o-t/security library"
```

---

## Task 2: Types and Schemas

**Files:**
- Create: `libraries/security/src/types.ts`
- Create: `libraries/security/src/schemas.ts`

**Step 1: Write types**

```typescript
// libraries/security/src/types.ts

export type Result<T> =
  | { success: true; data: T }
  | { success: false; error: string };

export type PathOptions = {
  allowAbsolute?: boolean;
  allowedExtensions?: string[];
  maxLength?: number;
  allowDotFiles?: boolean;
};

export type SanitizeHTMLOptions = {
  allowedTags?: string[];
  allowedAttributes?: Record<string, string[]>;
};
```

**Step 2: Write schemas**

```typescript
// libraries/security/src/schemas.ts
import { z } from "zod";

export const PathOptionsSchema = z.object({
  allowAbsolute: z.boolean().optional().default(false),
  allowedExtensions: z.array(z.string()).optional(),
  maxLength: z.number().int().positive().optional().default(255),
  allowDotFiles: z.boolean().optional().default(false),
});

export const SanitizeHTMLOptionsSchema = z.object({
  allowedTags: z.array(z.string()).optional(),
  allowedAttributes: z.record(z.array(z.string())).optional(),
});
```

**Step 3: Commit**

```bash
git add libraries/security/src/types.ts libraries/security/src/schemas.ts
git commit -m "feat(security): add types and schemas"
```

---

## Task 3: Path Security — sanitizePath and validatePath

**Files:**
- Create: `libraries/security/src/path/sanitize.ts`
- Create: `libraries/security/src/path/validate.ts`
- Test: `libraries/security/__tests__/path.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/security/__tests__/path.test.ts
import { describe, expect, test } from "bun:test";
import { sanitizePath } from "../src/path/sanitize";
import { validatePath } from "../src/path/validate";

describe("sanitizePath()", () => {
  test("resolves safe relative path", () => {
    expect(sanitizePath("uploads/file.txt", "/var/data")).toBe("/var/data/uploads/file.txt");
  });

  test("blocks path traversal with ../", () => {
    expect(() => sanitizePath("../../../etc/passwd", "/var/data")).toThrow();
  });

  test("blocks path traversal with encoded ../", () => {
    expect(() => sanitizePath("..%2F..%2Fetc/passwd", "/var/data")).toThrow();
  });

  test("blocks path traversal with backslashes", () => {
    expect(() => sanitizePath("..\\..\\etc\\passwd", "/var/data")).toThrow();
  });

  test("blocks null bytes", () => {
    expect(() => sanitizePath("file.txt\0.jpg", "/var/data")).toThrow();
  });

  test("blocks double encoding", () => {
    expect(() => sanitizePath("%252e%252e%252f", "/var/data")).toThrow();
  });

  test("allows nested safe paths", () => {
    expect(sanitizePath("a/b/c/file.txt", "/var/data")).toBe("/var/data/a/b/c/file.txt");
  });
});

describe("validatePath()", () => {
  test("validates a safe path", () => {
    const result = validatePath("file.txt");
    expect(result.success).toBe(true);
  });

  test("rejects absolute paths by default", () => {
    const result = validatePath("/etc/passwd");
    expect(result.success).toBe(false);
  });

  test("allows absolute when configured", () => {
    const result = validatePath("/tmp/file.txt", { allowAbsolute: true });
    expect(result.success).toBe(true);
  });

  test("enforces allowed extensions", () => {
    const result = validatePath("file.exe", { allowedExtensions: [".txt", ".pdf"] });
    expect(result.success).toBe(false);
  });

  test("enforces max length", () => {
    const longPath = "a".repeat(300) + ".txt";
    const result = validatePath(longPath, { maxLength: 255 });
    expect(result.success).toBe(false);
  });

  test("blocks dotfiles by default", () => {
    const result = validatePath(".env");
    expect(result.success).toBe(false);
  });

  test("allows dotfiles when configured", () => {
    const result = validatePath(".gitignore", { allowDotFiles: true });
    expect(result.success).toBe(true);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd libraries/security && bun test __tests__/path.test.ts`
Expected: FAIL

**Step 3: Implement path security**

```typescript
// libraries/security/src/path/sanitize.ts
import * as path from "node:path";

const TRAVERSAL_PATTERNS = [
  /\.\.\//g,
  /\.\.\\/g,
  /\.\.%2[fF]/g,
  /%2[eE]%2[eE]%2[fF]/g,
  /%252[eE]%252[eE]%252[fF]/g,
];

export function sanitizePath(userInput: string, baseDir: string): string {
  // Block null bytes
  if (userInput.includes("\0")) {
    throw new Error("Path contains null bytes");
  }

  // Decode percent-encoded sequences for detection
  let decoded = userInput;
  try {
    decoded = decodeURIComponent(decoded);
    // Double-decode to catch double encoding
    decoded = decodeURIComponent(decoded);
  } catch {
    // If decoding fails, use original
    decoded = userInput;
  }

  // Check for traversal patterns
  for (const pattern of TRAVERSAL_PATTERNS) {
    if (pattern.test(userInput) || pattern.test(decoded)) {
      throw new Error("Path traversal detected");
    }
  }

  // Also check the decoded version for ".."
  if (decoded.includes("..")) {
    throw new Error("Path traversal detected");
  }

  // Normalize and resolve
  const normalized = path.normalize(userInput).replace(/\\/g, "/");
  if (normalized.includes("..")) {
    throw new Error("Path traversal detected after normalization");
  }

  const resolved = path.resolve(baseDir, normalized);

  // Ensure resolved path is within baseDir
  if (!resolved.startsWith(path.resolve(baseDir))) {
    throw new Error("Path escapes base directory");
  }

  return resolved;
}
```

```typescript
// libraries/security/src/path/validate.ts
import * as path from "node:path";
import type { Result, PathOptions } from "../types";
import { PathOptionsSchema } from "../schemas";

export function validatePath(
  filePath: string,
  options?: Partial<PathOptions>,
): Result<string> {
  const opts = PathOptionsSchema.parse(options ?? {});

  // Check max length
  if (filePath.length > opts.maxLength) {
    return { success: false, error: `Path exceeds max length of ${opts.maxLength}` };
  }

  // Check absolute paths
  if (!opts.allowAbsolute && path.isAbsolute(filePath)) {
    return { success: false, error: "Absolute paths not allowed" };
  }

  // Check dotfiles
  const basename = path.basename(filePath);
  if (!opts.allowDotFiles && basename.startsWith(".")) {
    return { success: false, error: "Dotfiles not allowed" };
  }

  // Check allowed extensions
  if (opts.allowedExtensions && opts.allowedExtensions.length > 0) {
    const ext = path.extname(filePath).toLowerCase();
    if (!opts.allowedExtensions.includes(ext)) {
      return { success: false, error: `Extension ${ext} not allowed. Allowed: ${opts.allowedExtensions.join(", ")}` };
    }
  }

  // Check for traversal
  if (filePath.includes("..") || filePath.includes("\0")) {
    return { success: false, error: "Path contains dangerous characters" };
  }

  return { success: true, data: filePath };
}
```

**Step 4: Run tests**

Run: `cd libraries/security && bun test __tests__/path.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add libraries/security/src/path/ libraries/security/__tests__/path.test.ts
git commit -m "feat(security): add path traversal prevention (sanitizePath, validatePath)"
```

---

## Task 4: HTML/XSS Prevention — escapeHTML and sanitizeHTML

**Files:**
- Create: `libraries/security/src/html/escape.ts`
- Create: `libraries/security/src/html/sanitize.ts`
- Test: `libraries/security/__tests__/html.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/security/__tests__/html.test.ts
import { describe, expect, test } from "bun:test";
import { escapeHTML } from "../src/html/escape";
import { sanitizeHTML } from "../src/html/sanitize";

describe("escapeHTML()", () => {
  test("escapes < and >", () => {
    expect(escapeHTML("<script>alert('xss')</script>")).toBe(
      "&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;"
    );
  });

  test("escapes &", () => {
    expect(escapeHTML("foo & bar")).toBe("foo &amp; bar");
  });

  test("escapes quotes", () => {
    expect(escapeHTML('a "b" c')).toBe("a &quot;b&quot; c");
  });

  test("escapes single quotes", () => {
    expect(escapeHTML("it's")).toBe("it&#39;s");
  });

  test("handles empty string", () => {
    expect(escapeHTML("")).toBe("");
  });

  test("passes through safe text", () => {
    expect(escapeHTML("Hello World")).toBe("Hello World");
  });

  // OWASP XSS attack vectors
  test("blocks img onerror", () => {
    const result = escapeHTML('<img src=x onerror=alert(1)>');
    expect(result).not.toContain("<img");
  });

  test("blocks javascript: protocol", () => {
    const result = escapeHTML('<a href="javascript:alert(1)">');
    expect(result).not.toContain("javascript:");
  });
});

describe("sanitizeHTML()", () => {
  test("strips all tags by default", () => {
    expect(sanitizeHTML("<b>bold</b> <script>evil</script>")).toBe("bold evil");
  });

  test("allows specified tags", () => {
    const result = sanitizeHTML("<b>bold</b> <script>evil</script>", {
      allowedTags: ["b"],
    });
    expect(result).toBe("<b>bold</b> evil");
  });

  test("allows specified attributes", () => {
    const result = sanitizeHTML('<a href="/page" onclick="evil()">link</a>', {
      allowedTags: ["a"],
      allowedAttributes: { a: ["href"] },
    });
    expect(result).toBe('<a href="/page">link</a>');
  });

  test("strips event handlers from allowed tags", () => {
    const result = sanitizeHTML('<div onmouseover="alert(1)">hover</div>', {
      allowedTags: ["div"],
    });
    expect(result).not.toContain("onmouseover");
  });

  test("strips javascript: from href", () => {
    const result = sanitizeHTML('<a href="javascript:alert(1)">click</a>', {
      allowedTags: ["a"],
      allowedAttributes: { a: ["href"] },
    });
    expect(result).not.toContain("javascript:");
  });
});
```

**Step 2: Implement HTML security**

```typescript
// libraries/security/src/html/escape.ts
const ESCAPE_MAP: Record<string, string> = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
};

const ESCAPE_REGEX = /[&<>"']/g;

export function escapeHTML(input: string): string {
  return input.replace(ESCAPE_REGEX, (char) => ESCAPE_MAP[char] ?? char);
}
```

```typescript
// libraries/security/src/html/sanitize.ts
import type { SanitizeHTMLOptions } from "../types";

const TAG_REGEX = /<\/?([a-zA-Z][a-zA-Z0-9]*)\b([^>]*)>/g;
const ATTR_REGEX = /([a-zA-Z-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\S+))/g;
const DANGEROUS_ATTR_PREFIXES = ["on", "formaction"];
const DANGEROUS_PROTOCOLS = ["javascript:", "vbscript:", "data:text/html"];

function isEventHandler(attrName: string): boolean {
  return attrName.toLowerCase().startsWith("on");
}

function isDangerousValue(value: string): boolean {
  const normalized = value.trim().toLowerCase().replace(/\s+/g, "");
  return DANGEROUS_PROTOCOLS.some((p) => normalized.startsWith(p));
}

export function sanitizeHTML(
  input: string,
  options?: SanitizeHTMLOptions,
): string {
  const allowedTags = new Set(options?.allowedTags?.map((t) => t.toLowerCase()) ?? []);
  const allowedAttrs = options?.allowedAttributes ?? {};

  return input.replace(TAG_REGEX, (match, tagName: string, attrs: string) => {
    const tag = tagName.toLowerCase();

    if (!allowedTags.has(tag)) {
      return ""; // Strip disallowed tags
    }

    // Parse and filter attributes
    const tagAllowedAttrs = new Set(allowedAttrs[tag]?.map((a) => a.toLowerCase()) ?? []);
    const safeAttrs: string[] = [];

    let attrMatch: RegExpExecArray | null;
    const attrRegex = new RegExp(ATTR_REGEX.source, "g");
    while ((attrMatch = attrRegex.exec(attrs)) !== null) {
      const attrName = attrMatch[1]!.toLowerCase();
      const attrValue = attrMatch[2] ?? attrMatch[3] ?? attrMatch[4] ?? "";

      // Block event handlers
      if (isEventHandler(attrName)) continue;

      // Block dangerous protocols
      if (isDangerousValue(attrValue)) continue;

      // Only include allowed attributes
      if (tagAllowedAttrs.has(attrName)) {
        safeAttrs.push(`${attrName}="${attrValue}"`);
      }
    }

    // Detect if this is a closing tag
    if (match.startsWith("</")) {
      return `</${tag}>`;
    }

    const attrStr = safeAttrs.length > 0 ? ` ${safeAttrs.join(" ")}` : "";
    return `<${tag}${attrStr}>`;
  });
}
```

**Step 3: Run tests**

Run: `cd libraries/security && bun test __tests__/html.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add libraries/security/src/html/ libraries/security/__tests__/html.test.ts
git commit -m "feat(security): add XSS prevention (escapeHTML, sanitizeHTML)"
```

---

## Task 5: SQL Injection Prevention

**Files:**
- Create: `libraries/security/src/sql/escape.ts`
- Test: `libraries/security/__tests__/sql.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/security/__tests__/sql.test.ts
import { describe, expect, test } from "bun:test";
import { escapeSQLIdentifier, escapeSQLString } from "../src/sql/escape";

describe("escapeSQLIdentifier()", () => {
  test("wraps in double quotes", () => {
    expect(escapeSQLIdentifier("users")).toBe('"users"');
  });

  test("escapes embedded double quotes", () => {
    expect(escapeSQLIdentifier('table"name')).toBe('"table""name"');
  });

  test("blocks empty identifier", () => {
    expect(() => escapeSQLIdentifier("")).toThrow();
  });

  test("blocks semicolons", () => {
    expect(() => escapeSQLIdentifier("users; DROP TABLE")).toThrow();
  });

  test("blocks null bytes", () => {
    expect(() => escapeSQLIdentifier("users\0")).toThrow();
  });
});

describe("escapeSQLString()", () => {
  test("escapes single quotes", () => {
    expect(escapeSQLString("O'Reilly")).toBe("'O''Reilly'");
  });

  test("blocks null bytes", () => {
    expect(() => escapeSQLString("test\0value")).toThrow();
  });

  test("escapes backslashes", () => {
    expect(escapeSQLString("path\\to")).toBe("'path\\\\to'");
  });

  test("handles empty string", () => {
    expect(escapeSQLString("")).toBe("''");
  });

  // SQL injection vectors
  test("neutralizes UNION attack", () => {
    const result = escapeSQLString("' UNION SELECT * FROM users --");
    expect(result).not.toContain("UNION SELECT");
    expect(result.startsWith("'")).toBe(true);
    expect(result.endsWith("'")).toBe(true);
  });
});
```

**Step 2: Implement SQL escape**

```typescript
// libraries/security/src/sql/escape.ts

export function escapeSQLIdentifier(identifier: string): string {
  if (!identifier || identifier.length === 0) {
    throw new Error("SQL identifier cannot be empty");
  }
  if (identifier.includes("\0")) {
    throw new Error("SQL identifier contains null bytes");
  }
  if (identifier.includes(";")) {
    throw new Error("SQL identifier contains semicolons");
  }
  // Escape embedded double quotes by doubling them
  const escaped = identifier.replace(/"/g, '""');
  return `"${escaped}"`;
}

export function escapeSQLString(value: string): string {
  if (value.includes("\0")) {
    throw new Error("SQL string contains null bytes");
  }
  // Escape single quotes by doubling them, escape backslashes
  const escaped = value.replace(/\\/g, "\\\\").replace(/'/g, "''");
  return `'${escaped}'`;
}
```

**Step 3: Run tests, commit**

Run: `cd libraries/security && bun test __tests__/sql.test.ts`

```bash
git add libraries/security/src/sql/ libraries/security/__tests__/sql.test.ts
git commit -m "feat(security): add SQL injection prevention (escapeSQLIdentifier, escapeSQLString)"
```

---

## Task 6: Command Injection Prevention

**Files:**
- Create: `libraries/security/src/shell/escape.ts`
- Create: `libraries/security/src/shell/validate.ts`
- Test: `libraries/security/__tests__/shell.test.ts`

**Step 1: Write failing tests**

```typescript
// libraries/security/__tests__/shell.test.ts
import { describe, expect, test } from "bun:test";
import { escapeShellArg } from "../src/shell/escape";
import { validateCommand } from "../src/shell/validate";

describe("escapeShellArg()", () => {
  test("wraps in single quotes", () => {
    expect(escapeShellArg("hello")).toBe("'hello'");
  });

  test("escapes embedded single quotes", () => {
    expect(escapeShellArg("it's")).toBe("'it'\\''s'");
  });

  test("escapes command substitution", () => {
    const result = escapeShellArg("$(rm -rf /)");
    expect(result).not.toContain("$(");
  });

  test("escapes backticks", () => {
    const result = escapeShellArg("`rm -rf /`");
    expect(result).not.toContain("`rm");
  });

  test("escapes pipe", () => {
    const result = escapeShellArg("file | rm -rf /");
    expect(result.startsWith("'")).toBe(true);
  });
});

describe("validateCommand()", () => {
  test("allows whitelisted commands", () => {
    const result = validateCommand("ls", ["ls", "cat", "echo"]);
    expect(result.success).toBe(true);
  });

  test("blocks non-whitelisted commands", () => {
    const result = validateCommand("rm", ["ls", "cat"]);
    expect(result.success).toBe(false);
  });

  test("blocks commands with path traversal", () => {
    const result = validateCommand("../../bin/rm", ["rm"]);
    expect(result.success).toBe(false);
  });

  test("blocks commands with semicolons", () => {
    const result = validateCommand("ls; rm -rf /", ["ls"]);
    expect(result.success).toBe(false);
  });

  test("blocks commands with pipes", () => {
    const result = validateCommand("ls | cat /etc/passwd", ["ls"]);
    expect(result.success).toBe(false);
  });
});
```

**Step 2: Implement shell security**

```typescript
// libraries/security/src/shell/escape.ts

export function escapeShellArg(arg: string): string {
  // Wrap in single quotes, escape any embedded single quotes
  return "'" + arg.replace(/'/g, "'\\''") + "'";
}
```

```typescript
// libraries/security/src/shell/validate.ts
import type { Result } from "../types";

const DANGEROUS_CHARS = [";", "|", "&", "$", "`", "(", ")", "{", "}", "\n", "\r"];

export function validateCommand(
  cmd: string,
  allowlist: string[],
): Result<string> {
  // Extract base command (first word, no path)
  const baseCmd = cmd.split(/\s/)[0] ?? "";

  // Block path traversal in command
  if (baseCmd.includes("..") || baseCmd.includes("/") || baseCmd.includes("\\")) {
    return { success: false, error: "Command contains path characters" };
  }

  // Check for dangerous characters in the full command
  for (const char of DANGEROUS_CHARS) {
    if (cmd.includes(char)) {
      return { success: false, error: `Command contains dangerous character: ${char}` };
    }
  }

  // Check allowlist
  if (!allowlist.includes(baseCmd)) {
    return { success: false, error: `Command '${baseCmd}' not in allowlist` };
  }

  return { success: true, data: cmd };
}
```

**Step 3: Run tests, commit**

Run: `cd libraries/security && bun test __tests__/shell.test.ts`

```bash
git add libraries/security/src/shell/ libraries/security/__tests__/shell.test.ts
git commit -m "feat(security): add command injection prevention (escapeShellArg, validateCommand)"
```

---

## Task 7: Main Index + Documentation + Release

**Files:**
- Create: `libraries/security/src/index.ts`
- Create: `libraries/security/README.md`
- Create: `libraries/security/CHANGELOG.md`

**Step 1: Write index.ts**

```typescript
// libraries/security/src/index.ts

// Types
export type { Result, PathOptions, SanitizeHTMLOptions } from "./types";

// Schemas
export { PathOptionsSchema, SanitizeHTMLOptionsSchema } from "./schemas";

// Path security
export { sanitizePath } from "./path/sanitize";
export { validatePath } from "./path/validate";

// HTML/XSS prevention
export { escapeHTML } from "./html/escape";
export { sanitizeHTML } from "./html/sanitize";

// SQL injection prevention
export { escapeSQLIdentifier, escapeSQLString } from "./sql/escape";

// Command injection prevention
export { escapeShellArg } from "./shell/escape";
export { validateCommand } from "./shell/validate";
```

**Step 2: Write CHANGELOG.md**

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2026-02-XX

### Added

- **Path Security**
  - `sanitizePath()` — normalize paths and prevent traversal attacks
  - `validatePath()` — validate paths against rules (extensions, length, dotfiles)

- **HTML/XSS Prevention**
  - `escapeHTML()` — escape HTML entities (`<`, `>`, `&`, `"`, `'`)
  - `sanitizeHTML()` — allowlist-based HTML sanitizer with attribute filtering

- **SQL Injection Prevention**
  - `escapeSQLIdentifier()` — safely escape table/column names
  - `escapeSQLString()` — safely escape string values

- **Command Injection Prevention**
  - `escapeShellArg()` — wrap and escape shell arguments
  - `validateCommand()` — allowlist-based command validation

- **Core**
  - `Result<T>` type for safe error handling
  - Zod schemas for all options
  - Zero external dependencies (except Zod)

[1.0.0]: https://github.com/F-O-T/libraries/releases/tag/@f-o-t/security@1.0.0
```

**Step 3: Write README.md with usage examples**

Cover installation, all 4 modules with code examples, and security best practices.

**Step 4: Build and run all tests**

Run: `cd libraries/security && bun x --bun fot build && bun test`
Expected: All pass

**Step 5: Commit**

```bash
git add -A libraries/security/
git commit -m "feat(security): complete @f-o-t/security v1.0.0

Path traversal, XSS, SQL injection, and command injection prevention.
Pure functional API with Zod validation."
```
